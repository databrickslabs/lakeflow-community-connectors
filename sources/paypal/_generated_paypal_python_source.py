# ==============================================================================
# Merged Lakeflow Source: paypal
# ==============================================================================
# This file is auto-generated by tools/scripts/merge_python_source.py
# Do not edit manually. Make changes to the source files instead.
# ==============================================================================

from datetime import datetime, timedelta
from decimal import Decimal
from typing import Any, Iterator
import json

from pyspark.sql import Row
from pyspark.sql.datasource import DataSource, DataSourceReader, SimpleDataSourceStreamReader
from pyspark.sql.types import *
import base64
import requests


def register_lakeflow_source(spark):
    """Register the Lakeflow Python source with Spark."""

    ########################################################
    # libs/utils.py
    ########################################################

    def _parse_struct(value: Any, field_type: StructType) -> Row:
        """Parse a dictionary into a PySpark Row based on StructType schema."""
        if not isinstance(value, dict):
            raise ValueError(f"Expected a dictionary for StructType, got {type(value)}")
        # Spark Python -> Arrow conversion require missing StructType fields to be assigned None.
        if value == {}:
            raise ValueError(
                "field in StructType cannot be an empty dict. "
                "Please assign None as the default value instead."
            )
        field_dict = {}
        for field in field_type.fields:
            if field.name in value:
                field_dict[field.name] = parse_value(value.get(field.name), field.dataType)
            elif field.nullable:
                field_dict[field.name] = None
            else:
                raise ValueError(f"Field {field.name} is not nullable but not found in the input")
        return Row(**field_dict)


    def _parse_array(value: Any, field_type: ArrayType) -> list:
        """Parse a list into a PySpark array based on ArrayType schema."""
        if not isinstance(value, list):
            if field_type.containsNull:
                return [parse_value(value, field_type.elementType)]
            raise ValueError(f"Expected a list for ArrayType, got {type(value)}")
        return [parse_value(v, field_type.elementType) for v in value]


    def _parse_map(value: Any, field_type: MapType) -> dict:
        """Parse a dictionary into a PySpark map based on MapType schema."""
        if not isinstance(value, dict):
            raise ValueError(f"Expected a dictionary for MapType, got {type(value)}")
        return {
            parse_value(k, field_type.keyType): parse_value(v, field_type.valueType)
            for k, v in value.items()
        }


    def _parse_string(value: Any) -> str:
        """Convert value to string."""
        return str(value)


    def _parse_integer(value: Any) -> int:
        """Convert value to integer."""
        if isinstance(value, str) and value.strip():
            return int(float(value)) if "." in value else int(value)
        if isinstance(value, (int, float)):
            return int(value)
        raise ValueError(f"Cannot convert {value} to integer")


    def _parse_float(value: Any) -> float:
        """Convert value to float."""
        return float(value)


    def _parse_decimal(value: Any) -> Decimal:
        """Convert value to Decimal."""
        return Decimal(value) if isinstance(value, str) and value.strip() else Decimal(str(value))


    def _parse_boolean(value: Any) -> bool:
        """Convert value to boolean."""
        if isinstance(value, str):
            lowered = value.lower()
            if lowered in ("true", "t", "yes", "y", "1"):
                return True
            if lowered in ("false", "f", "no", "n", "0"):
                return False
        return bool(value)


    def _parse_date(value: Any) -> datetime.date:
        """Convert value to date."""
        if isinstance(value, str):
            for fmt in ("%Y-%m-%d", "%m/%d/%Y", "%d-%m-%Y", "%Y/%m/%d"):
                try:
                    return datetime.strptime(value, fmt).date()
                except ValueError:
                    continue
            return datetime.fromisoformat(value).date()
        if isinstance(value, datetime):
            return value.date()
        raise ValueError(f"Cannot convert {value} to date")


    def _parse_timestamp(value: Any) -> datetime:
        """Convert value to timestamp."""
        if isinstance(value, str):
            ts_value = value.replace("Z", "+00:00") if value.endswith("Z") else value
            try:
                return datetime.fromisoformat(ts_value)
            except ValueError:
                for fmt in ("%Y-%m-%d %H:%M:%S", "%Y/%m/%d %H:%M:%S"):
                    try:
                        return datetime.strptime(ts_value, fmt)
                    except ValueError:
                        continue
        elif isinstance(value, (int, float)):
            return datetime.fromtimestamp(value)
        elif isinstance(value, datetime):
            return value
        raise ValueError(f"Cannot convert {value} to timestamp")


    def _decode_string_to_bytes(value: str) -> bytes:
        """Try to decode a string as base64, then hex, then UTF-8."""
        try:
            return base64.b64decode(value)
        except Exception:
            pass
        try:
            return bytes.fromhex(value)
        except Exception:
            pass
        return value.encode("utf-8")


    def _parse_binary(value: Any) -> bytes:
        """Convert value to bytes. Tries base64, then hex, then UTF-8 for strings."""
        if isinstance(value, bytes):
            return value
        if isinstance(value, bytearray):
            return bytes(value)
        if isinstance(value, str):
            return _decode_string_to_bytes(value)
        if isinstance(value, list):
            return bytes(value)
        return str(value).encode("utf-8")


    # Mapping of primitive types to their parser functions
    _PRIMITIVE_PARSERS = {
        StringType: _parse_string,
        IntegerType: _parse_integer,
        LongType: _parse_integer,
        FloatType: _parse_float,
        DoubleType: _parse_float,
        DecimalType: _parse_decimal,
        BooleanType: _parse_boolean,
        DateType: _parse_date,
        TimestampType: _parse_timestamp,
        BinaryType: _parse_binary,
    }


    def parse_value(value: Any, field_type: DataType) -> Any:
        """
        Converts a JSON value into a PySpark-compatible data type based on the provided field type.
        """
        if value is None:
            return None

        # Handle complex types
        if isinstance(field_type, StructType):
            return _parse_struct(value, field_type)
        if isinstance(field_type, ArrayType):
            return _parse_array(value, field_type)
        if isinstance(field_type, MapType):
            return _parse_map(value, field_type)

        # Handle primitive types via type-based lookup
        try:
            field_type_class = type(field_type)
            if field_type_class in _PRIMITIVE_PARSERS:
                return _PRIMITIVE_PARSERS[field_type_class](value)

            # Check for custom UDT handling
            if hasattr(field_type, "fromJson"):
                return field_type.fromJson(value)

            raise TypeError(f"Unsupported field type: {field_type}")
        except (ValueError, TypeError) as e:
            raise ValueError(f"Error converting '{value}' ({type(value)}) to {field_type}: {str(e)}")


    ########################################################
    # sources/paypal/paypal.py
    ########################################################

    class LakeflowConnect:
        def __init__(self, options: dict[str, str]) -> None:
            """
            Initialize the PayPal connector with connection-level options.

            Expected options:
                - client_id: OAuth 2.0 client ID from PayPal Developer Dashboard
                - client_secret: OAuth 2.0 client secret from PayPal Developer Dashboard
                - environment (optional): 'sandbox' or 'production'. Defaults to 'sandbox'.
            """
            self.client_id = options.get("client_id")
            self.client_secret = options.get("client_secret")

            if not self.client_id or not self.client_secret:
                raise ValueError(
                    "PayPal connector requires 'client_id' and 'client_secret' in options"
                )

            # Determine base URL based on environment
            environment = options.get("environment", "sandbox").lower()
            if environment == "production":
                self.base_url = "https://api-m.paypal.com"
            else:
                self.base_url = "https://api-m.sandbox.paypal.com"

            # Configure session for API requests
            self._session = requests.Session()
            self._session.headers.update({"Content-Type": "application/json"})

            # Token caching
            self._access_token = None
            self._token_expires_at = None

        def _get_access_token(self) -> str:
            """
            Obtain or refresh OAuth 2.0 access token using client credentials flow.

            Tokens are cached and refreshed 5 minutes before expiration (9-hour lifetime).
            """
            # Check if cached token is still valid (with 5-minute buffer)
            if self._access_token and self._token_expires_at:
                buffer = timedelta(minutes=5)
                if datetime.now() + buffer < self._token_expires_at:
                    return self._access_token

            # Request new token
            token_url = f"{self.base_url}/v1/oauth2/token"

            # Create Basic auth header with Base64-encoded client_id:client_secret
            credentials = f"{self.client_id}:{self.client_secret}"
            encoded_credentials = base64.b64encode(credentials.encode()).decode()

            headers = {
                "Authorization": f"Basic {encoded_credentials}",
                "Content-Type": "application/x-www-form-urlencoded",
            }

            data = {"grant_type": "client_credentials"}

            response = requests.post(token_url, headers=headers, data=data, timeout=30)

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal OAuth token request failed: {response.status_code} {response.text}"
                )

            token_data = response.json()
            self._access_token = token_data.get("access_token")
            expires_in = token_data.get("expires_in", 32400)  # Default 9 hours

            self._token_expires_at = datetime.now() + timedelta(seconds=expires_in)

            return self._access_token

        def _make_request(
            self, method: str, endpoint: str, params: dict = None
        ) -> requests.Response:
            """
            Make an authenticated API request to PayPal.

            Args:
                method: HTTP method (GET, POST, etc.)
                endpoint: API endpoint path (e.g., '/v1/reporting/transactions')
                params: Query parameters

            Returns:
                Response object
            """
            access_token = self._get_access_token()

            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json",
            }

            url = f"{self.base_url}{endpoint}"

            response = self._session.request(
                method=method,
                url=url,
                headers=headers,
                params=params,
                timeout=30
            )

            # Handle common error cases
            if response.status_code == 401:
                # Token may have expired, clear cache and retry once
                self._access_token = None
                self._token_expires_at = None
                access_token = self._get_access_token()
                headers["Authorization"] = f"Bearer {access_token}"
                response = self._session.request(
                    method=method,
                    url=url,
                    headers=headers,
                    params=params,
                    timeout=30
                )

            if response.status_code == 429:
                retry_after = response.headers.get("Retry-After", "60")
                raise RuntimeError(
                    f"PayPal API rate limit exceeded. Retry after {retry_after} seconds."
                )

            if response.status_code not in [200, 201]:
                raise RuntimeError(
                    f"PayPal API error: {response.status_code} {response.text}"
                )

            return response

        def list_tables(self) -> list[str]:
            """
            List names of all tables supported by this connector.

            Currently returns: transactions, subscriptions, products, plans, payment_captures

            Note: 'invoices' table requires Invoicing API permissions (not available
            with basic sandbox credentials). The table is fully implemented but not 
            listed by default. Users with proper permissions can access it directly.

            Note: 'orders' table is not included because PayPal Orders API v2 
            does not support bulk listing. Use 'transactions' table instead.
            """
            return ["transactions", "subscriptions", "products", "plans", "payment_captures"]

        def get_table_schema(
            self, table_name: str, table_options: dict[str, str]
        ) -> StructType:
            """
            Fetch the schema of a table.

            Args:
                table_name: The name of the table to fetch the schema for.
                table_options: Additional options (not required for PayPal connector).

            Returns:
                A StructType object representing the schema of the table.
            """
            if table_name not in self.list_tables():
                raise ValueError(f"Unsupported table: {table_name!r}")

            # Common struct types used across multiple tables
            amount_struct = StructType([
                StructField("currency_code", StringType(), True),
                StructField("value", StringType(), True),
            ])

            address_struct = StructType([
                StructField("line1", StringType(), True),
                StructField("city", StringType(), True),
                StructField("country_code", StringType(), True),
                StructField("postal_code", StringType(), True),
            ])

            if table_name == "transactions":
                # Flattened transactions table schema
                # All fields from nested objects (transaction_info, payer_info, shipping_info, cart_info) 
                # are now top-level columns

                payer_name_struct = StructType([
                    StructField("given_name", StringType(), True),
                    StructField("surname", StringType(), True),
                ])

                # Item details for cart
                item_details_struct = StructType([
                    StructField("item_code", StringType(), True),
                    StructField("item_name", StringType(), True),
                    StructField("item_description", StringType(), True),
                    StructField("item_quantity", StringType(), True),
                    StructField("item_unit_price", amount_struct, True),
                    StructField("item_amount", amount_struct, True),
                ])

                # Flattened schema with all fields at top level
                transactions_schema = StructType([
                    # Fields from transaction_info
                    StructField("transaction_id", StringType(), False),
                    StructField("paypal_account_id", StringType(), True),
                    StructField("transaction_event_code", StringType(), True),
                    StructField("transaction_initiation_date", StringType(), True),
                    StructField("transaction_updated_date", StringType(), True),
                    StructField("transaction_amount", amount_struct, True),
                    StructField("fee_amount", amount_struct, True),
                    StructField("transaction_status", StringType(), True),
                    StructField("transaction_subject", StringType(), True),
                    StructField("ending_balance", amount_struct, True),
                    StructField("available_balance", amount_struct, True),
                    StructField("invoice_id", StringType(), True),
                    StructField("custom_field", StringType(), True),
                    StructField("protection_eligibility", StringType(), True),
                    # Fields from payer_info
                    StructField("payer_account_id", StringType(), True),
                    StructField("payer_email_address", StringType(), True),
                    StructField("payer_address_status", StringType(), True),
                    StructField("payer_status", StringType(), True),
                    StructField("payer_name", payer_name_struct, True),
                    StructField("payer_country_code", StringType(), True),
                    # Fields from shipping_info
                    StructField("shipping_name", StringType(), True),
                    StructField("shipping_address", address_struct, True),
                    # Fields from cart_info
                    StructField("item_details", ArrayType(item_details_struct, True), True),
                ])

                return transactions_schema

            if table_name == "invoices":
                # Invoice schema based on PayPal Invoicing API v2
                invoice_detail_struct = StructType([
                    StructField("invoice_number", StringType(), True),
                    StructField("reference", StringType(), True),
                    StructField("invoice_date", StringType(), True),
                    StructField("currency_code", StringType(), True),
                    StructField("note", StringType(), True),
                    StructField("term", StringType(), True),
                    StructField("memo", StringType(), True),
                ])

                invoicer_struct = StructType([
                    StructField("name", StringType(), True),
                    StructField("email_address", StringType(), True),
                    StructField("phones", ArrayType(StructType([
                        StructField("country_code", StringType(), True),
                        StructField("national_number", StringType(), True),
                        StructField("phone_type", StringType(), True),
                    ]), True), True),
                    StructField("website", StringType(), True),
                    StructField("tax_id", StringType(), True),
                    StructField("logo_url", StringType(), True),
                ])

                primary_recipient_struct = StructType([
                    StructField("billing_info", StructType([
                        StructField("email_address", StringType(), True),
                        StructField("language", StringType(), True),
                    ]), True),
                    StructField("shipping_info", StructType([
                        StructField("name", StringType(), True),
                        StructField("address", address_struct, True),
                    ]), True),
                ])

                item_struct = StructType([
                    StructField("name", StringType(), True),
                    StructField("description", StringType(), True),
                    StructField("quantity", StringType(), True),
                    StructField("unit_amount", amount_struct, True),
                    StructField("tax", StructType([
                        StructField("name", StringType(), True),
                        StructField("percent", StringType(), True),
                        StructField("amount", amount_struct, True),
                    ]), True),
                    StructField("item_date", StringType(), True),
                    StructField("discount", StructType([
                        StructField("percent", StringType(), True),
                        StructField("amount", amount_struct, True),
                    ]), True),
                ])

                amount_summary_struct = StructType([
                    StructField("currency_code", StringType(), True),
                    StructField("value", StringType(), True),
                ])

                invoices_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("parent_id", StringType(), True),
                    StructField("status", StringType(), True),
                    StructField("detail", invoice_detail_struct, True),
                    StructField("invoicer", invoicer_struct, True),
                    StructField("primary_recipients", ArrayType(primary_recipient_struct, True), True),
                    StructField("items", ArrayType(item_struct, True), True),
                    StructField("amount", StructType([
                        StructField("breakdown", StructType([
                            StructField("item_total", amount_summary_struct, True),
                            StructField("discount", amount_summary_struct, True),
                            StructField("tax_total", amount_summary_struct, True),
                            StructField("shipping", amount_summary_struct, True),
                        ]), True),
                    ]), True),
                    StructField("due_amount", amount_summary_struct, True),
                    StructField("gratuity", amount_summary_struct, True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return invoices_schema

            if table_name == "subscriptions":
                # Subscription schema based on PayPal Subscriptions API v1
                billing_info_struct = StructType([
                    StructField("outstanding_balance", amount_struct, True),
                    StructField("cycle_executions", ArrayType(StructType([
                        StructField("tenure_type", StringType(), True),
                        StructField("sequence", LongType(), True),
                        StructField("cycles_completed", LongType(), True),
                        StructField("cycles_remaining", LongType(), True),
                        StructField("total_cycles", LongType(), True),
                    ]), True), True),
                    StructField("last_payment", StructType([
                        StructField("amount", amount_struct, True),
                        StructField("time", StringType(), True),
                    ]), True),
                    StructField("next_billing_time", StringType(), True),
                    StructField("final_payment_time", StringType(), True),
                    StructField("failed_payments_count", LongType(), True),
                ])

                subscriber_struct = StructType([
                    StructField("email_address", StringType(), True),
                    StructField("payer_id", StringType(), True),
                    StructField("name", StructType([
                        StructField("given_name", StringType(), True),
                        StructField("surname", StringType(), True),
                    ]), True),
                    StructField("shipping_address", address_struct, True),
                ])

                subscriptions_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("plan_id", StringType(), True),
                    StructField("start_time", StringType(), True),
                    StructField("quantity", StringType(), True),
                    StructField("shipping_amount", amount_struct, True),
                    StructField("subscriber", subscriber_struct, True),
                    StructField("billing_info", billing_info_struct, True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("status", StringType(), True),
                    StructField("status_update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return subscriptions_schema

            if table_name == "orders":
                # Orders schema based on PayPal Orders API v2
                purchase_unit_struct = StructType([
                    StructField("reference_id", StringType(), True),
                    StructField("amount", StructType([
                        StructField("currency_code", StringType(), True),
                        StructField("value", StringType(), True),
                        StructField("breakdown", StructType([
                            StructField("item_total", amount_struct, True),
                            StructField("shipping", amount_struct, True),
                            StructField("handling", amount_struct, True),
                            StructField("tax_total", amount_struct, True),
                            StructField("insurance", amount_struct, True),
                            StructField("shipping_discount", amount_struct, True),
                            StructField("discount", amount_struct, True),
                        ]), True),
                    ]), True),
                    StructField("payee", StructType([
                        StructField("email_address", StringType(), True),
                        StructField("merchant_id", StringType(), True),
                    ]), True),
                    StructField("description", StringType(), True),
                    StructField("custom_id", StringType(), True),
                    StructField("invoice_id", StringType(), True),
                    StructField("soft_descriptor", StringType(), True),
                    StructField("items", ArrayType(StructType([
                        StructField("name", StringType(), True),
                        StructField("unit_amount", amount_struct, True),
                        StructField("tax", amount_struct, True),
                        StructField("quantity", StringType(), True),
                        StructField("description", StringType(), True),
                        StructField("sku", StringType(), True),
                        StructField("category", StringType(), True),
                    ]), True), True),
                    StructField("shipping", StructType([
                        StructField("name", StructType([
                            StructField("full_name", StringType(), True),
                        ]), True),
                        StructField("address", address_struct, True),
                    ]), True),
                    StructField("payments", StructType([
                        StructField("captures", ArrayType(StructType([
                            StructField("id", StringType(), True),
                            StructField("status", StringType(), True),
                            StructField("amount", amount_struct, True),
                            StructField("final_capture", BooleanType(), True),
                            StructField("seller_protection", StructType([
                                StructField("status", StringType(), True),
                                StructField("dispute_categories", ArrayType(StringType(), True), True),
                            ]), True),
                            StructField("create_time", StringType(), True),
                            StructField("update_time", StringType(), True),
                        ]), True), True),
                        StructField("refunds", ArrayType(StructType([
                            StructField("id", StringType(), True),
                            StructField("status", StringType(), True),
                            StructField("amount", amount_struct, True),
                            StructField("create_time", StringType(), True),
                            StructField("update_time", StringType(), True),
                        ]), True), True),
                    ]), True),
                ])

                payer_struct = StructType([
                    StructField("email_address", StringType(), True),
                    StructField("payer_id", StringType(), True),
                    StructField("name", StructType([
                        StructField("given_name", StringType(), True),
                        StructField("surname", StringType(), True),
                    ]), True),
                    StructField("phone", StructType([
                        StructField("phone_number", StructType([
                            StructField("national_number", StringType(), True),
                        ]), True),
                    ]), True),
                    StructField("address", address_struct, True),
                ])

                orders_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("intent", StringType(), True),
                    StructField("status", StringType(), True),
                    StructField("purchase_units", ArrayType(purchase_unit_struct, True), True),
                    StructField("payer", payer_struct, True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return orders_schema

            if table_name == "products":
                # Products schema based on PayPal Catalog Products API v1
                products_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("name", StringType(), True),
                    StructField("description", StringType(), True),
                    StructField("type", StringType(), True),
                    StructField("category", StringType(), True),
                    StructField("image_url", StringType(), True),
                    StructField("home_url", StringType(), True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return products_schema

            if table_name == "plans":
                # Billing Plans schema based on PayPal Subscriptions API v1
                billing_cycle_struct = StructType([
                    StructField("tenure_type", StringType(), True),
                    StructField("sequence", LongType(), True),
                    StructField("total_cycles", LongType(), True),
                    StructField("pricing_scheme", StructType([
                        StructField("fixed_price", amount_struct, True),
                        StructField("create_time", StringType(), True),
                        StructField("update_time", StringType(), True),
                    ]), True),
                    StructField("frequency", StructType([
                        StructField("interval_unit", StringType(), True),
                        StructField("interval_count", LongType(), True),
                    ]), True),
                ])

                payment_preferences_struct = StructType([
                    StructField("auto_bill_outstanding", BooleanType(), True),
                    StructField("setup_fee", amount_struct, True),
                    StructField("setup_fee_failure_action", StringType(), True),
                    StructField("payment_failure_threshold", LongType(), True),
                ])

                taxes_struct = StructType([
                    StructField("percentage", StringType(), True),
                    StructField("inclusive", BooleanType(), True),
                ])

                plans_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("product_id", StringType(), True),
                    StructField("name", StringType(), True),
                    StructField("status", StringType(), True),
                    StructField("description", StringType(), True),
                    StructField("billing_cycles", ArrayType(billing_cycle_struct, True), True),
                    StructField("payment_preferences", payment_preferences_struct, True),
                    StructField("taxes", taxes_struct, True),
                    StructField("quantity_supported", BooleanType(), True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return plans_schema

            if table_name == "payment_captures":
                # Payment Captures schema based on PayPal Payments API v2
                seller_protection_struct = StructType([
                    StructField("status", StringType(), True),
                    StructField("dispute_categories", ArrayType(StringType(), True), True),
                ])

                seller_receivable_breakdown_struct = StructType([
                    StructField("gross_amount", amount_struct, True),
                    StructField("paypal_fee", amount_struct, True),
                    StructField("net_amount", amount_struct, True),
                    StructField("receivable_amount", amount_struct, True),
                    StructField("exchange_rate", StructType([
                        StructField("source_currency", StringType(), True),
                        StructField("target_currency", StringType(), True),
                        StructField("value", StringType(), True),
                    ]), True),
                    StructField("platform_fees", ArrayType(StructType([
                        StructField("amount", amount_struct, True),
                        StructField("payee", StructType([
                            StructField("email_address", StringType(), True),
                            StructField("merchant_id", StringType(), True),
                        ]), True),
                    ]), True), True),
                ])

                payment_captures_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("status", StringType(), True),
                    StructField("status_details", StructType([
                        StructField("reason", StringType(), True),
                    ]), True),
                    StructField("amount", amount_struct, True),
                    StructField("invoice_id", StringType(), True),
                    StructField("custom_id", StringType(), True),
                    StructField("seller_protection", seller_protection_struct, True),
                    StructField("final_capture", BooleanType(), True),
                    StructField("seller_receivable_breakdown", seller_receivable_breakdown_struct, True),
                    StructField("disbursement_mode", StringType(), True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return payment_captures_schema

            raise ValueError(f"Unsupported table: {table_name!r}")

        def read_table_metadata(
            self, table_name: str, table_options: dict[str, str]
        ) -> dict:
            """
            Fetch metadata for the given table.

            Args:
                table_name: The name of the table to fetch metadata for.
                table_options: Additional options (not required for PayPal connector).

            Returns:
                A dictionary containing primary_keys, cursor_field, and ingestion_type.
            """
            if table_name not in self.list_tables():
                raise ValueError(f"Unsupported table: {table_name!r}")

            if table_name == "transactions":
                return {
                    "primary_keys": ["transaction_id"],
                    "cursor_field": "transaction_initiation_date",
                    "ingestion_type": "snapshot",
                }

            if table_name == "invoices":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "detail.invoice_date",
                    "ingestion_type": "snapshot",
                }

            if table_name == "subscriptions":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "orders":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "snapshot",
                }

            if table_name == "products":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "plans":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "payment_captures":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            raise ValueError(f"Unsupported table: {table_name!r}")

        def read_table(
            self, table_name: str, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Read records from a table and return raw JSON-like dictionaries.

            Args:
                table_name: The name of the table to read.
                start_offset: The offset to start reading from.
                table_options: Additional options including start_date and end_date.

            Returns:
                An iterator of records in JSON format and an offset.
            """
            if table_name not in self.list_tables():
                raise ValueError(f"Unsupported table: {table_name!r}")

            if table_name == "transactions":
                return self._read_transactions(start_offset, table_options)

            if table_name == "invoices":
                return self._read_invoices(start_offset, table_options)

            if table_name == "subscriptions":
                return self._read_subscriptions(start_offset, table_options)

            if table_name == "orders":
                return self._read_orders(start_offset, table_options)

            if table_name == "products":
                return self._read_products(start_offset, table_options)

            if table_name == "plans":
                return self._read_plans(start_offset, table_options)

            if table_name == "payment_captures":
                return self._read_payment_captures(start_offset, table_options)

            raise ValueError(f"Unsupported table: {table_name!r}")

        def _read_transactions(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'transactions' table.

            Required table_options:
                - start_date: ISO 8601 date string (e.g., '2024-01-01T00:00:00Z')
                - end_date: ISO 8601 date string (e.g., '2024-01-31T23:59:59Z')

            Optional table_options:
                - page_size: Number of transactions per page (default: 100, max: 500)

            The PayPal API enforces a maximum 31-day date range per request.
            """
            start_date = table_options.get("start_date")
            end_date = table_options.get("end_date")

            if not start_date or not end_date:
                raise ValueError(
                    "table_options for 'transactions' must include 'start_date' and 'end_date' "
                    "in ISO 8601 format (e.g., '2024-01-01T00:00:00Z')"
                )

            # Validate date range (PayPal enforces 31-day maximum)
            try:
                start_dt = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
                end_dt = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
                date_range = (end_dt - start_dt).days

                if date_range > 31:
                    raise ValueError(
                        f"Date range exceeds PayPal's 31-day maximum. "
                        f"Requested range: {date_range} days. "
                        f"Please split the date range into smaller windows."
                    )
            except ValueError as e:
                if "31-day" in str(e):
                    raise
                raise ValueError(
                    f"Invalid date format. Expected ISO 8601 format "
                    f"(e.g., '2024-01-01T00:00:00Z'): {e}"
                )

            # Get page size from options (default 100, max 500)
            try:
                page_size = int(table_options.get("page_size", 100))
            except (TypeError, ValueError):
                page_size = 100
            page_size = max(1, min(page_size, 500))

            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Build query parameters
            params = {
                "start_date": start_date,
                "end_date": end_date,
                "page_size": page_size,
                "page": page,
            }

            # Make API request
            response = self._make_request("GET", "/v1/reporting/transactions", params)

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal API error for transactions: {response.status_code} {response.text}"
                )

            data = response.json()

            # Extract transaction details array
            transaction_details = data.get("transaction_details", [])
            if not isinstance(transaction_details, list):
                raise ValueError(
                    f"Unexpected response format for transaction_details: "
                    f"{type(transaction_details).__name__}"
                )

            # Process records - flatten nested objects into top-level fields
            records: list[dict[str, Any]] = []
            for txn in transaction_details:
                transaction_info = txn.get("transaction_info", {}) or {}
                payer_info = txn.get("payer_info", {}) or {}
                shipping_info = txn.get("shipping_info", {}) or {}
                cart_info = txn.get("cart_info", {}) or {}

                # Flatten all fields to top level
                record: dict[str, Any] = {
                    # Fields from transaction_info
                    "transaction_id": transaction_info.get("transaction_id"),
                    "paypal_account_id": transaction_info.get("paypal_account_id"),
                    "transaction_event_code": transaction_info.get("transaction_event_code"),
                    "transaction_initiation_date": transaction_info.get("transaction_initiation_date"),
                    "transaction_updated_date": transaction_info.get("transaction_updated_date"),
                    "transaction_amount": transaction_info.get("transaction_amount"),
                    "fee_amount": transaction_info.get("fee_amount"),
                    "transaction_status": transaction_info.get("transaction_status"),
                    "transaction_subject": transaction_info.get("transaction_subject"),
                    "ending_balance": transaction_info.get("ending_balance"),
                    "available_balance": transaction_info.get("available_balance"),
                    "invoice_id": transaction_info.get("invoice_id"),
                    "custom_field": transaction_info.get("custom_field"),
                    "protection_eligibility": transaction_info.get("protection_eligibility"),
                    # Fields from payer_info
                    "payer_account_id": payer_info.get("account_id"),
                    "payer_email_address": payer_info.get("email_address"),
                    "payer_address_status": payer_info.get("address_status"),
                    "payer_status": payer_info.get("payer_status"),
                    "payer_name": payer_info.get("payer_name"),
                    "payer_country_code": payer_info.get("country_code"),
                    # Fields from shipping_info
                    "shipping_name": shipping_info.get("name"),
                    "shipping_address": shipping_info.get("address"),
                    # Fields from cart_info
                    "item_details": cart_info.get("item_details"),
                }
                records.append(record)

            # Determine next offset based on pagination metadata
            total_pages = data.get("total_pages", 1)
            current_page = data.get("page", page)

            # If there are more pages, increment page number
            if current_page < total_pages:
                next_offset = {"page": current_page + 1}
            else:
                # No more pages - return same offset to indicate end of data
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_invoices(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'invoices' table.

            Uses PayPal Invoicing API v2: GET /v2/invoicing/invoices

            Optional table_options:
                - page: Page number (default: 1)
                - page_size: Number of invoices per page (default: 20, max: 100)
                - total_required: Whether to show total count (default: false)
            """
            # Get pagination parameters
            try:
                page_size = int(table_options.get("page_size", 20))
            except (TypeError, ValueError):
                page_size = 20
            page_size = max(1, min(page_size, 100))

            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Build query parameters
            params = {
                "page": page,
                "page_size": page_size,
                "total_required": table_options.get("total_required", "false"),
            }

            # Make API request
            response = self._make_request("GET", "/v2/invoicing/invoices", params)

            if response.status_code == 403:
                raise RuntimeError(
                    f"PayPal Invoicing API requires specific permissions. "
                    f"Please enable Invoicing API access for your PayPal app in the Developer Dashboard. "
                    f"Error: {response.status_code} {response.text}"
                )

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal API error for invoices: {response.status_code} {response.text}"
                )

            data = response.json()

            # Extract invoices array
            invoices = data.get("items", [])
            if not isinstance(invoices, list):
                raise ValueError(
                    f"Unexpected response format for invoices: {type(invoices).__name__}"
                )

            # Process records - keep nested structure
            records: list[dict[str, Any]] = []
            for invoice in invoices:
                records.append(invoice)

            # Check if there are more pages using links
            links = data.get("links", [])
            has_next = any(link.get("rel") == "next" for link in links if isinstance(link, dict))

            # If there are more pages, increment page number
            if has_next:
                next_offset = {"page": page + 1}
            else:
                # No more pages - return same offset to indicate end of data
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_subscriptions(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'subscriptions' table.

            Uses PayPal Subscriptions API v1: GET /v1/billing/subscriptions/{id}

            IMPORTANT: PayPal does NOT support bulk listing of subscriptions.
            You must provide subscription IDs in table_options.

            Required table_options:
                - subscription_ids: List or comma-separated string of subscription IDs
                                    Example: ["I-ABC123", "I-DEF456"] or "I-ABC123,I-DEF456"

            Optional table_options:
                - include_transactions: If true, fetch transaction details for each subscription
            """
            # Get subscription IDs from table_options
            subscription_ids = table_options.get("subscription_ids", [])

            # Handle comma-separated string or list
            if isinstance(subscription_ids, str):
                subscription_ids = [sid.strip() for sid in subscription_ids.split(",") if sid.strip()]
            elif not isinstance(subscription_ids, list):
                raise ValueError(
                    "table_options for 'subscriptions' must include 'subscription_ids' as a list or comma-separated string. "
                    "Example: {'subscription_ids': ['I-ABC123', 'I-DEF456']} or {'subscription_ids': 'I-ABC123,I-DEF456'}. "
                    "\n\nNote: PayPal does not support bulk listing of subscriptions - you must provide specific IDs."
                )

            if not subscription_ids:
                raise ValueError(
                    "table_options for 'subscriptions' must include at least one subscription ID in 'subscription_ids'. "
                    "\n\nNote: PayPal does not support bulk listing of subscriptions - you must provide specific IDs. "
                    "You can find subscription IDs in your PayPal dashboard or from subscription creation responses."
                )

            # Check if we've already processed all subscriptions
            # Use a simple "done" flag instead of index-based pagination
            if start_offset and start_offset.get("done"):
                # Already processed all - return empty with same offset
                return iter([]), start_offset

            # Fetch ALL subscription details in one call
            records: list[dict[str, Any]] = []
            include_transactions = table_options.get("include_transactions", "false").lower() == "true"

            # Process ALL subscriptions
            for subscription_id in subscription_ids:
                try:
                    # Fetch subscription details
                    response = self._make_request("GET", f"/v1/billing/subscriptions/{subscription_id}")

                    if response.status_code == 200:
                        subscription_data = response.json()

                        # Optionally fetch transactions for this subscription
                        if include_transactions:
                            try:
                                txn_response = self._make_request(
                                    "GET",
                                    f"/v1/billing/subscriptions/{subscription_id}/transactions",
                                    {"start_time": subscription_data.get("start_time"), "end_time": subscription_data.get("update_time")}
                                )
                                if txn_response.status_code == 200:
                                    subscription_data["transactions"] = txn_response.json().get("transactions", [])
                            except Exception:
                                # Transactions endpoint might not be available
                                subscription_data["transactions"] = None

                        records.append(subscription_data)
                    else:
                        # Log error but continue (subscription might not exist or be inaccessible)
                        print(f"Warning: Could not fetch subscription {subscription_id}: {response.status_code}")

                except Exception as e:
                    # Log error but continue processing other subscriptions
                    print(f"Warning: Error fetching subscription {subscription_id}: {e}")

            # All subscriptions processed - signal completion with done flag
            # For next call, return same offset ({"done": True}) to indicate no more data
            next_offset = {"done": True}

            return iter(records), next_offset

        def _read_orders(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'orders' table.

            Note: PayPal Orders API v2 does not provide a direct "list all orders" endpoint.
            Orders are typically created and retrieved by ID, or accessed through 
            Transaction Search API.

            This implementation attempts to use available endpoints, but may have limitations.
            Consider using the 'transactions' table for order history instead.
            """
            # PayPal Orders API v2 is primarily for creating/managing individual orders
            # There is no bulk "list orders" endpoint in the standard API

            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Since there's no list endpoint, we return an informative error
            raise RuntimeError(
                "PayPal Orders API v2 does not support bulk order listing. "
                "Orders are created and retrieved individually by ID. "
                "To retrieve order/payment history, use the 'transactions' table instead, "
                "which provides comprehensive transaction data including order information."
            )

        def _read_products(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'products' table.

            Uses PayPal Catalog Products API v1: GET /v1/catalogs/products

            Optional table_options:
                - page: Page number (default: 1)
                - page_size: Number of products per page (default: 20, max: 20)
            """
            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Get page size from options (default 20, max 20)
            try:
                page_size = int(table_options.get("page_size", 20))
            except (TypeError, ValueError):
                page_size = 20
            page_size = max(1, min(page_size, 20))

            # Build query parameters
            params = {
                "page": page,
                "page_size": page_size,
            }

            # Make API request
            response = self._make_request("GET", "/v1/catalogs/products", params)

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal API error for products: {response.status_code} {response.text}"
                )

            data = response.json()

            # Extract products array
            products = data.get("products", [])
            if not isinstance(products, list):
                raise ValueError(
                    f"Unexpected response format for products: {type(products).__name__}"
                )

            # Process records
            records: list[dict[str, Any]] = []
            for product in products:
                records.append(product)

            # Check for pagination
            total_items = data.get("total_items", 0)
            total_pages = data.get("total_pages", 1)

            # If there are more pages, increment page number
            if page < total_pages:
                next_offset = {"page": page + 1}
            else:
                # No more pages - return same offset to indicate end of data
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_plans(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'plans' table.

            Uses PayPal Subscriptions API v1: GET /v1/billing/plans

            Optional table_options:
                - product_id: Filter by product ID
                - plan_ids: Comma-separated plan IDs to filter
                - page: Page number (default: 1)
                - page_size: Number of plans per page (default: 20, max: 20)
            """
            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Get page size from options (default 20, max 20)
            try:
                page_size = int(table_options.get("page_size", 20))
            except (TypeError, ValueError):
                page_size = 20
            page_size = max(1, min(page_size, 20))

            # Build query parameters
            params = {
                "page": page,
                "page_size": page_size,
            }

            # Add optional filters
            if table_options.get("product_id"):
                params["product_id"] = table_options["product_id"]
            if table_options.get("plan_ids"):
                params["plan_ids"] = table_options["plan_ids"]

            # Make API request
            response = self._make_request("GET", "/v1/billing/plans", params)

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal API error for plans: {response.status_code} {response.text}"
                )

            data = response.json()

            # Extract plans array
            plans = data.get("plans", [])
            if not isinstance(plans, list):
                raise ValueError(
                    f"Unexpected response format for plans: {type(plans).__name__}"
                )

            # Process records
            records: list[dict[str, Any]] = []
            for plan in plans:
                records.append(plan)

            # Check for pagination
            total_items = data.get("total_items", 0)
            total_pages = data.get("total_pages", 1)

            # If there are more pages, increment page number
            if page < total_pages:
                next_offset = {"page": page + 1}
            else:
                # No more pages - return same offset to indicate end of data
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_payment_captures(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'payment_captures' table.

            Uses PayPal Transaction Search API v1 to find captures: GET /v1/reporting/transactions

            Required table_options:
                - start_date: Start of date range in ISO 8601 format (UTC)
                - end_date: End of date range in ISO 8601 format (UTC)

            Optional table_options:
                - page_size: Number of captures per page (default: 100, max: 500)

            Note: This uses the Transaction Search API and filters for capture transactions only.
            """
            start_date = table_options.get("start_date")
            end_date = table_options.get("end_date")

            if not start_date or not end_date:
                raise ValueError(
                    "table_options for 'payment_captures' must include 'start_date' and 'end_date' "
                    "in ISO 8601 format (e.g., '2024-01-01T00:00:00Z')"
                )

            # Validate date range (PayPal enforces 31-day maximum)
            try:
                start_dt = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
                end_dt = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
                date_range = (end_dt - start_dt).days

                if date_range > 31:
                    raise ValueError(
                        f"Date range exceeds PayPal's 31-day maximum. "
                        f"Requested range: {date_range} days. "
                        f"Please split the date range into smaller windows."
                    )
            except ValueError as e:
                if "31-day" in str(e):
                    raise
                raise ValueError(
                    f"Invalid date format. Expected ISO 8601 format "
                    f"(e.g., '2024-01-01T00:00:00Z'): {e}"
                )

            # Get page size from options (default 100, max 500)
            try:
                page_size = int(table_options.get("page_size", 100))
            except (TypeError, ValueError):
                page_size = 100
            page_size = max(1, min(page_size, 500))

            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Build query parameters
            params = {
                "start_date": start_date,
                "end_date": end_date,
                "page_size": page_size,
                "page": page,
            }

            # Make API request
            response = self._make_request("GET", "/v1/reporting/transactions", params)

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal API error for payment_captures: {response.status_code} {response.text}"
                )

            data = response.json()

            # Extract transaction details array
            transaction_details = data.get("transaction_details", [])
            if not isinstance(transaction_details, list):
                raise ValueError(
                    f"Unexpected response format for transaction_details: "
                    f"{type(transaction_details).__name__}"
                )

            # Process records - extract capture information from transactions
            records: list[dict[str, Any]] = []
            for txn in transaction_details:
                transaction_info = txn.get("transaction_info", {}) or {}

                # Build a capture record from transaction data
                record: dict[str, Any] = {
                    "id": transaction_info.get("transaction_id"),
                    "status": "COMPLETED" if transaction_info.get("transaction_status") == "S" else "PENDING",
                    "status_details": None,
                    "amount": transaction_info.get("transaction_amount"),
                    "invoice_id": transaction_info.get("invoice_id"),
                    "custom_id": transaction_info.get("custom_field"),
                    "seller_protection": {
                        "status": transaction_info.get("protection_eligibility"),
                        "dispute_categories": None,
                    },
                    "final_capture": True,
                    "seller_receivable_breakdown": {
                        "gross_amount": transaction_info.get("transaction_amount"),
                        "paypal_fee": transaction_info.get("fee_amount"),
                        "net_amount": transaction_info.get("ending_balance"),
                        "receivable_amount": transaction_info.get("transaction_amount"),
                        "exchange_rate": None,
                        "platform_fees": None,
                    },
                    "disbursement_mode": "INSTANT",
                    "create_time": transaction_info.get("transaction_initiation_date"),
                    "update_time": transaction_info.get("transaction_updated_date"),
                    "links": None,
                }
                records.append(record)

            # Determine next offset based on pagination metadata
            total_pages = data.get("total_pages", 1)
            current_page = data.get("page", page)

            # If there are more pages, increment page number
            if current_page < total_pages:
                next_offset = {"page": current_page + 1}
            else:
                # No more pages - return same offset to indicate end of data
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset


    ########################################################
    # pipeline/lakeflow_python_source.py
    ########################################################

    METADATA_TABLE = "_lakeflow_metadata"
    TABLE_NAME = "tableName"
    TABLE_NAME_LIST = "tableNameList"
    TABLE_CONFIGS = "tableConfigs"
    IS_DELETE_FLOW = "isDeleteFlow"


    class LakeflowStreamReader(SimpleDataSourceStreamReader):
        """
        Implements a data source stream reader for Lakeflow Connect.
        Currently, only the simpleStreamReader is implemented, which uses a
        more generic protocol suitable for most data sources that support
        incremental loading.
        """

        def __init__(
            self,
            options: dict[str, str],
            schema: StructType,
            lakeflow_connect: LakeflowConnect,
        ):
            self.options = options
            self.lakeflow_connect = lakeflow_connect
            self.schema = schema

        def initialOffset(self):
            return {}

        def read(self, start: dict) -> (Iterator[tuple], dict):
            is_delete_flow = self.options.get(IS_DELETE_FLOW) == "true"
            # Strip delete flow options before passing to connector
            table_options = {
                k: v for k, v in self.options.items() if k != IS_DELETE_FLOW
            }

            if is_delete_flow:
                records, offset = self.lakeflow_connect.read_table_deletes(
                    self.options[TABLE_NAME], start, table_options
                )
            else:
                records, offset = self.lakeflow_connect.read_table(
                    self.options[TABLE_NAME], start, table_options
                )
            rows = map(lambda x: parse_value(x, self.schema), records)
            return rows, offset

        def readBetweenOffsets(self, start: dict, end: dict) -> Iterator[tuple]:
            # TODO: This does not ensure the records returned are identical across repeated calls.
            # For append-only tables, the data source must guarantee that reading from the same
            # start offset will always yield the same set of records.
            # For tables ingested as incremental CDC, it is only necessary that no new changes
            # are missed in the returned records.
            return self.read(start)[0]


    class LakeflowBatchReader(DataSourceReader):
        def __init__(
            self,
            options: dict[str, str],
            schema: StructType,
            lakeflow_connect: LakeflowConnect,
        ):
            self.options = options
            self.schema = schema
            self.lakeflow_connect = lakeflow_connect
            self.table_name = options[TABLE_NAME]

        def read(self, partition):
            all_records = []
            if self.table_name == METADATA_TABLE:
                all_records = self._read_table_metadata()
            else:
                all_records, _ = self.lakeflow_connect.read_table(
                    self.table_name, None, self.options
                )

            rows = map(lambda x: parse_value(x, self.schema), all_records)
            return iter(rows)

        def _read_table_metadata(self):
            table_name_list = self.options.get(TABLE_NAME_LIST, "")
            table_names = [o.strip() for o in table_name_list.split(",") if o.strip()]
            all_records = []
            table_configs = json.loads(self.options.get(TABLE_CONFIGS, "{}"))
            for table in table_names:
                metadata = self.lakeflow_connect.read_table_metadata(
                    table, table_configs.get(table, {})
                )
                all_records.append({TABLE_NAME: table, **metadata})
            return all_records


    class LakeflowSource(DataSource):
        def __init__(self, options):
            self.options = options
            self.lakeflow_connect = LakeflowConnect(options)

        @classmethod
        def name(cls):
            return "lakeflow_connect"

        def schema(self):
            table = self.options[TABLE_NAME]
            if table == METADATA_TABLE:
                return StructType(
                    [
                        StructField(TABLE_NAME, StringType(), False),
                        StructField("primary_keys", ArrayType(StringType()), True),
                        StructField("cursor_field", StringType(), True),
                        StructField("ingestion_type", StringType(), True),
                    ]
                )
            else:
                # Assuming the LakeflowConnect interface uses get_table_schema, not get_table_details
                return self.lakeflow_connect.get_table_schema(table, self.options)

        def reader(self, schema: StructType):
            return LakeflowBatchReader(self.options, schema, self.lakeflow_connect)

        def simpleStreamReader(self, schema: StructType):
            return LakeflowStreamReader(self.options, schema, self.lakeflow_connect)


    spark.dataSource.register(LakeflowSource)  # pylint: disable=undefined-variable
