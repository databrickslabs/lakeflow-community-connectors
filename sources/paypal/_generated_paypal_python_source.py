# ==============================================================================
# Merged Lakeflow Source: paypal
# ==============================================================================
# This file is auto-generated by tools/scripts/merge_python_source.py
# Do not edit manually. Make changes to the source files instead.
# ==============================================================================


def register_lakeflow_source(spark):
    """Register the Lakeflow Python source with Spark."""
    
    # Import all dependencies inside the function to avoid scoping issues
    from datetime import datetime
    from decimal import Decimal
    from typing import Any, Iterator
    import json
    import base64
    
    from pyspark.sql import Row
    from pyspark.sql.datasource import DataSource, DataSourceReader, SimpleDataSourceStreamReader
    from pyspark.sql.types import (
        StructType, StructField, StringType, LongType, DoubleType, 
        BooleanType, TimestampType, ArrayType, MapType, DecimalType, 
        DateType, BinaryType, IntegerType, FloatType, DataType
    )

    ########################################################
    # libs/utils.py
    ########################################################

    def _parse_struct(value: Any, field_type: StructType) -> Row:
        """Parse a dictionary into a PySpark Row based on StructType schema."""
        if not isinstance(value, dict):
            raise ValueError(f"Expected a dictionary for StructType, got {type(value)}")
        # Spark Python -> Arrow conversion require missing StructType fields to be assigned None.
        if value == {}:
            raise ValueError(
                "field in StructType cannot be an empty dict. "
                "Please assign None as the default value instead."
            )
        field_dict = {}
        for field in field_type.fields:
            if field.name in value:
                field_dict[field.name] = parse_value(value.get(field.name), field.dataType)
            elif field.nullable:
                field_dict[field.name] = None
            else:
                raise ValueError(f"Field {field.name} is not nullable but not found in the input")
        return Row(**field_dict)


    def _parse_array(value: Any, field_type: ArrayType) -> list:
        """Parse a list into a PySpark array based on ArrayType schema."""
        if not isinstance(value, list):
            if field_type.containsNull:
                return [parse_value(value, field_type.elementType)]
            raise ValueError(f"Expected a list for ArrayType, got {type(value)}")
        return [parse_value(v, field_type.elementType) for v in value]


    def _parse_map(value: Any, field_type: MapType) -> dict:
        """Parse a dictionary into a PySpark map based on MapType schema."""
        if not isinstance(value, dict):
            raise ValueError(f"Expected a dictionary for MapType, got {type(value)}")
        return {
            parse_value(k, field_type.keyType): parse_value(v, field_type.valueType)
            for k, v in value.items()
        }


    def _parse_string(value: Any) -> str:
        """Convert value to string."""
        return str(value)


    def _parse_integer(value: Any) -> int:
        """Convert value to integer."""
        if isinstance(value, str) and value.strip():
            return int(float(value)) if "." in value else int(value)
        if isinstance(value, (int, float)):
            return int(value)
        raise ValueError(f"Cannot convert {value} to integer")


    def _parse_float(value: Any) -> float:
        """Convert value to float."""
        return float(value)


    def _parse_decimal(value: Any) -> Decimal:
        """Convert value to Decimal."""
        return Decimal(value) if isinstance(value, str) and value.strip() else Decimal(str(value))


    def _parse_boolean(value: Any) -> bool:
        """Convert value to boolean."""
        if isinstance(value, str):
            lowered = value.lower()
            if lowered in ("true", "t", "yes", "y", "1"):
                return True
            if lowered in ("false", "f", "no", "n", "0"):
                return False
        return bool(value)


    def _parse_date(value: Any) -> datetime.date:
        """Convert value to date."""
        if isinstance(value, str):
            for fmt in ("%Y-%m-%d", "%m/%d/%Y", "%d-%m-%Y", "%Y/%m/%d"):
                try:
                    return datetime.strptime(value, fmt).date()
                except ValueError:
                    continue
            return datetime.fromisoformat(value).date()
        if isinstance(value, datetime):
            return value.date()
        raise ValueError(f"Cannot convert {value} to date")


    def _parse_timestamp(value: Any) -> datetime:
        """Convert value to timestamp."""
        if isinstance(value, str):
            ts_value = value.replace("Z", "+00:00") if value.endswith("Z") else value
            try:
                return datetime.fromisoformat(ts_value)
            except ValueError:
                for fmt in ("%Y-%m-%d %H:%M:%S", "%Y/%m/%d %H:%M:%S"):
                    try:
                        return datetime.strptime(ts_value, fmt)
                    except ValueError:
                        continue
        elif isinstance(value, (int, float)):
            return datetime.fromtimestamp(value)
        elif isinstance(value, datetime):
            return value
        raise ValueError(f"Cannot convert {value} to timestamp")


    def _decode_string_to_bytes(value: str) -> bytes:
        """Try to decode a string as base64, then hex, then UTF-8."""
        try:
            return base64.b64decode(value)
        except Exception:
            pass
        try:
            return bytes.fromhex(value)
        except Exception:
            pass
        return value.encode("utf-8")


    def _parse_binary(value: Any) -> bytes:
        """Convert value to bytes. Tries base64, then hex, then UTF-8 for strings."""
        if isinstance(value, bytes):
            return value
        if isinstance(value, bytearray):
            return bytes(value)
        if isinstance(value, str):
            return _decode_string_to_bytes(value)
        if isinstance(value, list):
            return bytes(value)
        return str(value).encode("utf-8")


    # Mapping of primitive types to their parser functions
    _PRIMITIVE_PARSERS = {
        StringType: _parse_string,
        IntegerType: _parse_integer,
        LongType: _parse_integer,
        FloatType: _parse_float,
        DoubleType: _parse_float,
        DecimalType: _parse_decimal,
        BooleanType: _parse_boolean,
        DateType: _parse_date,
        TimestampType: _parse_timestamp,
        BinaryType: _parse_binary,
    }


    def parse_value(value: Any, field_type: DataType) -> Any:
        """
        Converts a JSON value into a PySpark-compatible data type based on the provided field type.
        """
        if value is None:
            return None

        # Handle complex types
        if isinstance(field_type, StructType):
            return _parse_struct(value, field_type)
        if isinstance(field_type, ArrayType):
            return _parse_array(value, field_type)
        if isinstance(field_type, MapType):
            return _parse_map(value, field_type)

        # Handle primitive types via type-based lookup
        try:
            field_type_class = type(field_type)
            if field_type_class in _PRIMITIVE_PARSERS:
                return _PRIMITIVE_PARSERS[field_type_class](value)

            # Check for custom UDT handling
            if hasattr(field_type, "fromJson"):
                return field_type.fromJson(value)

            raise TypeError(f"Unsupported field type: {field_type}")
        except (ValueError, TypeError) as e:
            raise ValueError(f"Error converting '{value}' ({type(value)}) to {field_type}: {str(e)}")


    ########################################################
    # sources/paypal/paypal.py
    ########################################################

    """
    PayPal Community Connector for Databricks Lakeflow

    METHODOLOGY & ARCHITECTURE:
    ===========================

    This connector implements a robust, production-ready integration with PayPal's REST API
    using industry best practices for authentication, pagination, and error handling.

    KEY DESIGN PATTERNS:
    -------------------
    1. **OAuth 2.0 Token Caching**: Tokens are cached with intelligent refresh (9-hour lifetime)
    2. **Pagination Strategy**: Supports multiple pagination types:
       - Page-based (transactions, products, plans)  
       - ID-based with batch fetching (subscriptions)
    3. **Schema-First Approach**: All schemas explicitly defined to prevent data loss
    4. **Graceful Degradation**: Failed API calls log warnings but don't crash pipeline
    5. **CDC Support**: Change Data Capture via cursor_field tracking

    REUSABILITY & EXTENSIBILITY:
    ---------------------------
    - Abstract base patterns applicable to any REST API
    - Configurable via connection options (no hardcoding)
    - Modular design: each table has independent read method
    - Easy to add new tables following existing patterns

    EFFICIENCY OPTIMIZATIONS:
    ------------------------
    - Session reuse for HTTP connection pooling
    - Token caching reduces auth overhead
    - Batch processing for subscriptions
    - Configurable page sizes for optimal throughput

    For detailed API documentation, see: sources/paypal/README.md
    """

    import requests
    import base64
    import logging
    from datetime import datetime, timedelta
    from typing import Iterator, Any, Optional, Dict, List

    from pyspark.sql.types import (
        StructType,
        StructField,
        LongType,
        StringType,
        BooleanType,
        ArrayType,
    )

    # Configure logging
    logger = logging.getLogger(__name__)

    # Constants for API configuration
    TOKEN_EXPIRY_BUFFER_MINUTES = 5  # Refresh tokens 5 minutes before expiry
    DEFAULT_TOKEN_LIFETIME_SECONDS = 32400  # 9 hours
    DEFAULT_REQUEST_TIMEOUT_SECONDS = 30
    MAX_RETRIES_ON_RATE_LIMIT = 3

    # Pagination constants
    DEFAULT_PAGE_SIZE_TRANSACTIONS = 100
    MAX_PAGE_SIZE_TRANSACTIONS = 500
    DEFAULT_PAGE_SIZE_PRODUCTS = 20
    MAX_PAGE_SIZE_PRODUCTS = 100
    DEFAULT_PAGE_SIZE_PLANS = 20
    MAX_PAGE_SIZE_PLANS = 100


    class LakeflowConnect:
        def __init__(self, options: Dict[str, str]) -> None:
            """
            Initialize the PayPal connector with connection-level options.

            This constructor implements secure credential handling and environment-aware
            configuration, following OAuth 2.0 client credentials flow best practices.

            Args:
                options: Dictionary containing:
                    - client_id (required): OAuth 2.0 client ID from PayPal Developer Dashboard
                    - client_secret (required): OAuth 2.0 client secret 
                    - environment (optional): 'sandbox' or 'production'. Defaults to 'sandbox'.

            Raises:
                ValueError: If required credentials are missing

            Example:
                >>> connector = LakeflowConnect({
                ...     "client_id": "your_client_id",
                ...     "client_secret": "your_client_secret",
                ...     "environment": "sandbox"
                ... })
            """
            self.client_id = options.get("client_id")
            self.client_secret = options.get("client_secret")

            if not self.client_id or not self.client_secret:
                error_msg = "PayPal connector requires 'client_id' and 'client_secret' in options"
                logger.error(error_msg)
                raise ValueError(error_msg)

            # Determine base URL based on environment
            environment = options.get("environment", "sandbox").lower()
            if environment == "production":
                self.base_url = "https://api-m.paypal.com"
                logger.info("PayPal connector initialized for PRODUCTION environment")
            else:
                self.base_url = "https://api-m.sandbox.paypal.com"
                logger.info("PayPal connector initialized for SANDBOX environment")

            # Configure session for API requests (enables connection pooling)
            self._session = requests.Session()
            self._session.headers.update({"Content-Type": "application/json"})

            # Token caching for efficiency (reduces auth overhead)
            self._access_token: Optional[str] = None
            self._token_expires_at: Optional[datetime] = None

            logger.debug("PayPal connector initialization complete")

        def _get_access_token(self) -> str:
            """
            Obtain or refresh OAuth 2.0 access token using client credentials flow.

            METHODOLOGY: Implements intelligent token caching with expiry buffer to minimize
            auth overhead. Tokens are proactively refreshed 5 minutes before expiration.

            Token Lifecycle:
            1. Check if cached token exists and is still valid (with buffer)
            2. If valid, reuse cached token (efficiency optimization)
            3. If expired/missing, request new token from PayPal
            4. Cache new token with calculated expiry time

            Returns:
                str: Valid OAuth 2.0 access token

            Raises:
                RuntimeError: If authentication fails
            """
            # Check if cached token is still valid (with buffer for proactive refresh)
            if self._access_token and self._token_expires_at:
                buffer = timedelta(minutes=TOKEN_EXPIRY_BUFFER_MINUTES)
                if datetime.now() + buffer < self._token_expires_at:
                    logger.debug("Reusing cached access token")
                    return self._access_token

            logger.info("Requesting new PayPal access token")

            # Request new token
            token_url = f"{self.base_url}/v1/oauth2/token"

            # Create Basic auth header with Base64-encoded client_id:client_secret
            credentials = f"{self.client_id}:{self.client_secret}"
            encoded_credentials = base64.b64encode(credentials.encode()).decode()

            headers = {
                "Authorization": f"Basic {encoded_credentials}",
                "Content-Type": "application/x-www-form-urlencoded",
            }

            data = {"grant_type": "client_credentials"}

            response = requests.post(
                token_url, 
                headers=headers, 
                data=data, 
                timeout=DEFAULT_REQUEST_TIMEOUT_SECONDS
            )

            if response.status_code != 200:
                logger.error(f"PayPal OAuth failed: {response.status_code}")
                raise RuntimeError(
                    f"PayPal OAuth token request failed: {response.status_code} {response.text}"
                )

            token_data = response.json()
            self._access_token = token_data.get("access_token")
            expires_in = token_data.get("expires_in", DEFAULT_TOKEN_LIFETIME_SECONDS)

            self._token_expires_at = datetime.now() + timedelta(seconds=expires_in)

            logger.info(f"Access token obtained, expires in {expires_in/3600:.1f} hours")

            return self._access_token

        def _make_request(
            self, method: str, endpoint: str, params: dict = None
        ) -> requests.Response:
            """
            Make an authenticated API request to PayPal.

            Args:
                method: HTTP method (GET, POST, etc.)
                endpoint: API endpoint path (e.g., '/v1/reporting/transactions')
                params: Query parameters

            Returns:
                Response object
            """
            access_token = self._get_access_token()

            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json",
            }

            url = f"{self.base_url}{endpoint}"

            response = self._session.request(
                method=method,
                url=url,
                headers=headers,
                params=params,
                timeout=30
            )

            # Handle common error cases
            if response.status_code == 401:
                # Token may have expired, clear cache and retry once
                self._access_token = None
                self._token_expires_at = None
                access_token = self._get_access_token()
                headers["Authorization"] = f"Bearer {access_token}"
                response = self._session.request(
                    method=method,
                    url=url,
                    headers=headers,
                    params=params,
                    timeout=30
                )

            if response.status_code == 429:
                retry_after = response.headers.get("Retry-After", "60")
                raise RuntimeError(
                    f"PayPal API rate limit exceeded. Retry after {retry_after} seconds."
                )

            if response.status_code not in [200, 201]:
                raise RuntimeError(
                    f"PayPal API error: {response.status_code} {response.text}"
                )

            return response

        def list_tables(self) -> list[str]:
            """
            List names of all tables supported by this connector.

            Returns ALL PayPal data APIs:
            - transactions: Transaction Search API (most comprehensive)
            - subscriptions: Billing Subscriptions  
            - products: Catalog Products
            - plans: Billing Plans
            - payment_captures: Payment Captures
            - disputes: Customer Disputes
            - payouts: Payout Batches
            - refunds: Payment Refunds
            - payment_authorizations: Payment Authorizations
            - webhooks_events: Webhook Events History
            - invoices: Invoicing API (requires special permissions)
            - orders: Orders API (ID-based fetching)
            - payment_experiences: Web Payment Profiles
            - tracking: Shipment Tracking
            """
            return [
                "transactions",
                "subscriptions", 
                "products",
                "plans",
                "payment_captures",
                "disputes",
                "payouts",
                "refunds",
                "payment_authorizations",
                "webhooks_events",
                "invoices",
                "orders",
                "payment_experiences",
                "tracking"
            ]

        def get_table_schema(
            self, table_name: str, table_options: dict[str, str]
        ) -> StructType:
            """
            Fetch the schema of a table.

            Args:
                table_name: The name of the table to fetch the schema for.
                table_options: Additional options (not required for PayPal connector).

            Returns:
                A StructType object representing the schema of the table.
            """
            if table_name not in self.list_tables():
                raise ValueError(f"Unsupported table: {table_name!r}")

            # Common struct types used across multiple tables
            amount_struct = StructType([
                StructField("currency_code", StringType(), True),
                StructField("value", StringType(), True),
            ])

            address_struct = StructType([
                StructField("line1", StringType(), True),
                StructField("city", StringType(), True),
                StructField("country_code", StringType(), True),
                StructField("postal_code", StringType(), True),
            ])

            if table_name == "transactions":
                # Flattened transactions table schema
                # All fields from nested objects (transaction_info, payer_info, shipping_info, cart_info) 
                # are now top-level columns

                payer_name_struct = StructType([
                    StructField("given_name", StringType(), True),
                    StructField("surname", StringType(), True),
                ])

                # Item details for cart
                item_details_struct = StructType([
                    StructField("item_code", StringType(), True),
                    StructField("item_name", StringType(), True),
                    StructField("item_description", StringType(), True),
                    StructField("item_quantity", StringType(), True),
                    StructField("item_unit_price", amount_struct, True),
                    StructField("item_amount", amount_struct, True),
                ])

                # Flattened schema with all fields at top level
                transactions_schema = StructType([
                    # Fields from transaction_info
                    StructField("transaction_id", StringType(), False),
                    StructField("paypal_account_id", StringType(), True),
                    StructField("transaction_event_code", StringType(), True),
                    StructField("transaction_initiation_date", StringType(), True),
                    StructField("transaction_updated_date", StringType(), True),
                    StructField("transaction_amount", amount_struct, True),
                    StructField("fee_amount", amount_struct, True),
                    StructField("transaction_status", StringType(), True),
                    StructField("transaction_subject", StringType(), True),
                    StructField("ending_balance", amount_struct, True),
                    StructField("available_balance", amount_struct, True),
                    StructField("invoice_id", StringType(), True),
                    StructField("custom_field", StringType(), True),
                    StructField("protection_eligibility", StringType(), True),
                    # Fields from payer_info
                    StructField("payer_account_id", StringType(), True),
                    StructField("payer_email_address", StringType(), True),
                    StructField("payer_address_status", StringType(), True),
                    StructField("payer_status", StringType(), True),
                    StructField("payer_name", payer_name_struct, True),
                    StructField("payer_country_code", StringType(), True),
                    # Fields from shipping_info
                    StructField("shipping_name", StringType(), True),
                    StructField("shipping_address", address_struct, True),
                    # Fields from cart_info
                    StructField("item_details", ArrayType(item_details_struct, True), True),
                ])

                return transactions_schema

            if table_name == "invoices":
                # Invoice schema based on PayPal Invoicing API v2
                invoice_detail_struct = StructType([
                    StructField("invoice_number", StringType(), True),
                    StructField("reference", StringType(), True),
                    StructField("invoice_date", StringType(), True),
                    StructField("currency_code", StringType(), True),
                    StructField("note", StringType(), True),
                    StructField("term", StringType(), True),
                    StructField("memo", StringType(), True),
                ])

                invoicer_struct = StructType([
                    StructField("name", StringType(), True),
                    StructField("email_address", StringType(), True),
                    StructField("phones", ArrayType(StructType([
                        StructField("country_code", StringType(), True),
                        StructField("national_number", StringType(), True),
                        StructField("phone_type", StringType(), True),
                    ]), True), True),
                    StructField("website", StringType(), True),
                    StructField("tax_id", StringType(), True),
                    StructField("logo_url", StringType(), True),
                ])

                primary_recipient_struct = StructType([
                    StructField("billing_info", StructType([
                        StructField("email_address", StringType(), True),
                        StructField("language", StringType(), True),
                    ]), True),
                    StructField("shipping_info", StructType([
                        StructField("name", StringType(), True),
                        StructField("address", address_struct, True),
                    ]), True),
                ])

                item_struct = StructType([
                    StructField("name", StringType(), True),
                    StructField("description", StringType(), True),
                    StructField("quantity", StringType(), True),
                    StructField("unit_amount", amount_struct, True),
                    StructField("tax", StructType([
                        StructField("name", StringType(), True),
                        StructField("percent", StringType(), True),
                        StructField("amount", amount_struct, True),
                    ]), True),
                    StructField("item_date", StringType(), True),
                    StructField("discount", StructType([
                        StructField("percent", StringType(), True),
                        StructField("amount", amount_struct, True),
                    ]), True),
                ])

                amount_summary_struct = StructType([
                    StructField("currency_code", StringType(), True),
                    StructField("value", StringType(), True),
                ])

                invoices_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("parent_id", StringType(), True),
                    StructField("status", StringType(), True),
                    StructField("detail", invoice_detail_struct, True),
                    StructField("invoicer", invoicer_struct, True),
                    StructField("primary_recipients", ArrayType(primary_recipient_struct, True), True),
                    StructField("items", ArrayType(item_struct, True), True),
                    StructField("amount", StructType([
                        StructField("breakdown", StructType([
                            StructField("item_total", amount_summary_struct, True),
                            StructField("discount", amount_summary_struct, True),
                            StructField("tax_total", amount_summary_struct, True),
                            StructField("shipping", amount_summary_struct, True),
                        ]), True),
                    ]), True),
                    StructField("due_amount", amount_summary_struct, True),
                    StructField("gratuity", amount_summary_struct, True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return invoices_schema

            if table_name == "subscriptions":
                # Subscription schema based on PayPal Subscriptions API v1
                billing_info_struct = StructType([
                    StructField("outstanding_balance", amount_struct, True),
                    StructField("cycle_executions", ArrayType(StructType([
                        StructField("tenure_type", StringType(), True),
                        StructField("sequence", LongType(), True),
                        StructField("cycles_completed", LongType(), True),
                        StructField("cycles_remaining", LongType(), True),
                        StructField("total_cycles", LongType(), True),
                    ]), True), True),
                    StructField("last_payment", StructType([
                        StructField("amount", amount_struct, True),
                        StructField("time", StringType(), True),
                    ]), True),
                    StructField("next_billing_time", StringType(), True),
                    StructField("final_payment_time", StringType(), True),
                    StructField("failed_payments_count", LongType(), True),
                ])

                subscriber_struct = StructType([
                    StructField("email_address", StringType(), True),
                    StructField("payer_id", StringType(), True),
                    StructField("name", StructType([
                        StructField("given_name", StringType(), True),
                        StructField("surname", StringType(), True),
                    ]), True),
                    StructField("shipping_address", address_struct, True),
                ])

                subscriptions_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("plan_id", StringType(), True),
                    StructField("start_time", StringType(), True),
                    StructField("quantity", StringType(), True),
                    StructField("shipping_amount", amount_struct, True),
                    StructField("subscriber", subscriber_struct, True),
                    StructField("billing_info", billing_info_struct, True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("status", StringType(), True),
                    StructField("status_update_time", StringType(), True),
                    StructField("custom_id", StringType(), True),  # Missing field!
                    StructField("plan_overridden", StringType(), True),  # Missing field!
                    StructField("plan", StructType([  # Missing field!
                        StructField("product_id", StringType(), True),
                        StructField("name", StringType(), True),
                        StructField("description", StringType(), True),
                    ]), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return subscriptions_schema

            if table_name == "orders":
                # Orders schema based on PayPal Orders API v2
                purchase_unit_struct = StructType([
                    StructField("reference_id", StringType(), True),
                    StructField("amount", StructType([
                        StructField("currency_code", StringType(), True),
                        StructField("value", StringType(), True),
                        StructField("breakdown", StructType([
                            StructField("item_total", amount_struct, True),
                            StructField("shipping", amount_struct, True),
                            StructField("handling", amount_struct, True),
                            StructField("tax_total", amount_struct, True),
                            StructField("insurance", amount_struct, True),
                            StructField("shipping_discount", amount_struct, True),
                            StructField("discount", amount_struct, True),
                        ]), True),
                    ]), True),
                    StructField("payee", StructType([
                        StructField("email_address", StringType(), True),
                        StructField("merchant_id", StringType(), True),
                    ]), True),
                    StructField("description", StringType(), True),
                    StructField("custom_id", StringType(), True),
                    StructField("invoice_id", StringType(), True),
                    StructField("soft_descriptor", StringType(), True),
                    StructField("items", ArrayType(StructType([
                        StructField("name", StringType(), True),
                        StructField("unit_amount", amount_struct, True),
                        StructField("tax", amount_struct, True),
                        StructField("quantity", StringType(), True),
                        StructField("description", StringType(), True),
                        StructField("sku", StringType(), True),
                        StructField("category", StringType(), True),
                    ]), True), True),
                    StructField("shipping", StructType([
                        StructField("name", StructType([
                            StructField("full_name", StringType(), True),
                        ]), True),
                        StructField("address", address_struct, True),
                    ]), True),
                    StructField("payments", StructType([
                        StructField("captures", ArrayType(StructType([
                            StructField("id", StringType(), True),
                            StructField("status", StringType(), True),
                            StructField("amount", amount_struct, True),
                            StructField("final_capture", BooleanType(), True),
                            StructField("seller_protection", StructType([
                                StructField("status", StringType(), True),
                                StructField("dispute_categories", ArrayType(StringType(), True), True),
                            ]), True),
                            StructField("create_time", StringType(), True),
                            StructField("update_time", StringType(), True),
                        ]), True), True),
                        StructField("refunds", ArrayType(StructType([
                            StructField("id", StringType(), True),
                            StructField("status", StringType(), True),
                            StructField("amount", amount_struct, True),
                            StructField("create_time", StringType(), True),
                            StructField("update_time", StringType(), True),
                        ]), True), True),
                    ]), True),
                ])

                payer_struct = StructType([
                    StructField("email_address", StringType(), True),
                    StructField("payer_id", StringType(), True),
                    StructField("name", StructType([
                        StructField("given_name", StringType(), True),
                        StructField("surname", StringType(), True),
                    ]), True),
                    StructField("phone", StructType([
                        StructField("phone_number", StructType([
                            StructField("national_number", StringType(), True),
                        ]), True),
                    ]), True),
                    StructField("address", address_struct, True),
                ])

                orders_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("intent", StringType(), True),
                    StructField("status", StringType(), True),
                    StructField("purchase_units", ArrayType(purchase_unit_struct, True), True),
                    StructField("payer", payer_struct, True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return orders_schema

            if table_name == "products":
                # Products schema based on PayPal Catalog Products API v1
                products_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("name", StringType(), True),
                    StructField("description", StringType(), True),
                    StructField("type", StringType(), True),
                    StructField("category", StringType(), True),
                    StructField("image_url", StringType(), True),
                    StructField("home_url", StringType(), True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return products_schema

            if table_name == "plans":
                # Billing Plans schema based on PayPal Subscriptions API v1
                billing_cycle_struct = StructType([
                    StructField("tenure_type", StringType(), True),
                    StructField("sequence", LongType(), True),
                    StructField("total_cycles", LongType(), True),
                    StructField("pricing_scheme", StructType([
                        StructField("fixed_price", amount_struct, True),
                        StructField("create_time", StringType(), True),
                        StructField("update_time", StringType(), True),
                    ]), True),
                    StructField("frequency", StructType([
                        StructField("interval_unit", StringType(), True),
                        StructField("interval_count", LongType(), True),
                    ]), True),
                ])

                payment_preferences_struct = StructType([
                    StructField("auto_bill_outstanding", BooleanType(), True),
                    StructField("setup_fee", amount_struct, True),
                    StructField("setup_fee_failure_action", StringType(), True),
                    StructField("payment_failure_threshold", LongType(), True),
                ])

                taxes_struct = StructType([
                    StructField("percentage", StringType(), True),
                    StructField("inclusive", BooleanType(), True),
                ])

                plans_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("product_id", StringType(), True),
                    StructField("name", StringType(), True),
                    StructField("status", StringType(), True),
                    StructField("description", StringType(), True),
                    StructField("billing_cycles", ArrayType(billing_cycle_struct, True), True),
                    StructField("payment_preferences", payment_preferences_struct, True),
                    StructField("taxes", taxes_struct, True),
                    StructField("quantity_supported", BooleanType(), True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return plans_schema

            if table_name == "payment_captures":
                # Payment Captures schema based on PayPal Payments API v2
                seller_protection_struct = StructType([
                    StructField("status", StringType(), True),
                    StructField("dispute_categories", ArrayType(StringType(), True), True),
                ])

                seller_receivable_breakdown_struct = StructType([
                    StructField("gross_amount", amount_struct, True),
                    StructField("paypal_fee", amount_struct, True),
                    StructField("net_amount", amount_struct, True),
                    StructField("receivable_amount", amount_struct, True),
                    StructField("exchange_rate", StructType([
                        StructField("source_currency", StringType(), True),
                        StructField("target_currency", StringType(), True),
                        StructField("value", StringType(), True),
                    ]), True),
                    StructField("platform_fees", ArrayType(StructType([
                        StructField("amount", amount_struct, True),
                        StructField("payee", StructType([
                            StructField("email_address", StringType(), True),
                            StructField("merchant_id", StringType(), True),
                        ]), True),
                    ]), True), True),
                ])

                payment_captures_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("status", StringType(), True),
                    StructField("status_details", StructType([
                        StructField("reason", StringType(), True),
                    ]), True),
                    StructField("amount", amount_struct, True),
                    StructField("invoice_id", StringType(), True),
                    StructField("custom_id", StringType(), True),
                    StructField("seller_protection", seller_protection_struct, True),
                    StructField("final_capture", BooleanType(), True),
                    StructField("seller_receivable_breakdown", seller_receivable_breakdown_struct, True),
                    StructField("disbursement_mode", StringType(), True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return payment_captures_schema

            if table_name == "disputes":
                # Disputes schema based on PayPal Disputes API v1
                money_struct = StructType([
                    StructField("currency_code", StringType(), True),
                    StructField("value", StringType(), True),
                ])

                disputes_schema = StructType([
                    StructField("dispute_id", StringType(), False),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("reason", StringType(), True),
                    StructField("status", StringType(), True),
                    StructField("dispute_state", StringType(), True),
                    StructField("dispute_life_cycle_stage", StringType(), True),
                    StructField("dispute_channel", StringType(), True),
                    StructField("dispute_amount", money_struct, True),
                    StructField("seller_transaction_id", StringType(), True),
                    StructField("buyer_user_id", StringType(), True),
                    StructField("seller_user_id", StringType(), True),
                    StructField("offer", StructType([
                        StructField("buyer_requested_amount", money_struct, True),
                        StructField("seller_offered_amount", money_struct, True),
                        StructField("offer_type", StringType(), True),
                    ]), True),
                    StructField("messages", ArrayType(StructType([
                        StructField("posted_by", StringType(), True),
                        StructField("time_posted", StringType(), True),
                        StructField("content", StringType(), True),
                    ]), True), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return disputes_schema

            if table_name == "payouts":
                # Payouts schema based on PayPal Payouts API v1
                payouts_schema = StructType([
                    StructField("batch_id", StringType(), False),
                    StructField("payout_batch_id", StringType(), True),
                    StructField("batch_status", StringType(), True),
                    StructField("time_created", StringType(), True),
                    StructField("time_completed", StringType(), True),
                    StructField("sender_batch_header", StructType([
                        StructField("sender_batch_id", StringType(), True),
                        StructField("email_subject", StringType(), True),
                        StructField("email_message", StringType(), True),
                    ]), True),
                    StructField("amount", StructType([
                        StructField("currency", StringType(), True),
                        StructField("value", StringType(), True),
                    ]), True),
                    StructField("fees", StructType([
                        StructField("currency", StringType(), True),
                        StructField("value", StringType(), True),
                    ]), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return payouts_schema

            if table_name == "refunds":
                # Refunds schema based on PayPal Payments API v2
                refunds_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("status", StringType(), True),
                    StructField("status_details", StructType([
                        StructField("reason", StringType(), True),
                    ]), True),
                    StructField("amount", amount_struct, True),
                    StructField("invoice_id", StringType(), True),
                    StructField("custom_id", StringType(), True),
                    StructField("acquirer_reference_number", StringType(), True),
                    StructField("note_to_payer", StringType(), True),
                    StructField("seller_payable_breakdown", StructType([
                        StructField("gross_amount", amount_struct, True),
                        StructField("paypal_fee", amount_struct, True),
                        StructField("net_amount", amount_struct, True),
                        StructField("total_refunded_amount", amount_struct, True),
                    ]), True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return refunds_schema

            if table_name == "payment_authorizations":
                # Payment Authorizations schema based on PayPal Payments API v2
                authorizations_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("status", StringType(), True),
                    StructField("status_details", StructType([
                        StructField("reason", StringType(), True),
                    ]), True),
                    StructField("amount", amount_struct, True),
                    StructField("invoice_id", StringType(), True),
                    StructField("custom_id", StringType(), True),
                    StructField("seller_protection", StructType([
                        StructField("status", StringType(), True),
                        StructField("dispute_categories", ArrayType(StringType(), True), True),
                    ]), True),
                    StructField("expiration_time", StringType(), True),
                    StructField("create_time", StringType(), True),
                    StructField("update_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return authorizations_schema

            if table_name == "webhooks_events":
                # Webhook Events schema based on PayPal Webhooks API v1
                webhooks_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("create_time", StringType(), True),
                    StructField("resource_type", StringType(), True),
                    StructField("event_version", StringType(), True),
                    StructField("event_type", StringType(), True),
                    StructField("summary", StringType(), True),
                    StructField("resource", StringType(), True),  # JSON string - varies by event type
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return webhooks_schema

            if table_name == "payment_experiences":
                # Payment Experiences (Web Profiles) schema based on PayPal Payment Experience API v1
                experiences_schema = StructType([
                    StructField("id", StringType(), False),
                    StructField("name", StringType(), True),
                    StructField("temporary", BooleanType(), True),
                    StructField("flow_config", StructType([
                        StructField("landing_page_type", StringType(), True),
                        StructField("bank_txn_pending_url", StringType(), True),
                        StructField("user_action", StringType(), True),
                    ]), True),
                    StructField("input_fields", StructType([
                        StructField("allow_note", BooleanType(), True),
                        StructField("no_shipping", LongType(), True),
                        StructField("address_override", LongType(), True),
                    ]), True),
                    StructField("presentation", StructType([
                        StructField("brand_name", StringType(), True),
                        StructField("logo_image", StringType(), True),
                        StructField("locale_code", StringType(), True),
                    ]), True),
                ])

                return experiences_schema

            if table_name == "tracking":
                # Tracking schema based on PayPal Tracking API v1
                tracking_schema = StructType([
                    StructField("transaction_id", StringType(), False),
                    StructField("tracking_number", StringType(), True),
                    StructField("status", StringType(), True),
                    StructField("carrier", StringType(), True),
                    StructField("carrier_name_other", StringType(), True),
                    StructField("postage_payment_id", StringType(), True),
                    StructField("notify_buyer", BooleanType(), True),
                    StructField("quantity", LongType(), True),
                    StructField("tracking_number_type", StringType(), True),
                    StructField("shipment_date", StringType(), True),
                    StructField("shipment_uploader", StringType(), True),
                    StructField("last_updated_time", StringType(), True),
                    StructField("links", ArrayType(StructType([
                        StructField("href", StringType(), True),
                        StructField("rel", StringType(), True),
                        StructField("method", StringType(), True),
                    ]), True), True),
                ])

                return tracking_schema

            raise ValueError(f"Unsupported table: {table_name!r}")

        def read_table_metadata(
            self, table_name: str, table_options: dict[str, str]
        ) -> dict:
            """
            Fetch metadata for the given table.

            Args:
                table_name: The name of the table to fetch metadata for.
                table_options: Additional options (not required for PayPal connector).

            Returns:
                A dictionary containing primary_keys, cursor_field, and ingestion_type.
            """
            if table_name not in self.list_tables():
                raise ValueError(f"Unsupported table: {table_name!r}")

            if table_name == "transactions":
                return {
                    "primary_keys": ["transaction_id"],
                    "cursor_field": "transaction_initiation_date",
                    "ingestion_type": "snapshot",
                }

            if table_name == "invoices":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "detail.invoice_date",
                    "ingestion_type": "snapshot",
                }

            if table_name == "subscriptions":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "orders":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "snapshot",
                }

            if table_name == "products":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "plans":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "payment_captures":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "disputes":
                return {
                    "primary_keys": ["dispute_id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "payouts":
                return {
                    "primary_keys": ["batch_id"],
                    "cursor_field": "time_created",
                    "ingestion_type": "cdc",
                }

            if table_name == "refunds":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "payment_authorizations":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "update_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "webhooks_events":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "create_time",
                    "ingestion_type": "cdc",
                }

            if table_name == "payment_experiences":
                return {
                    "primary_keys": ["id"],
                    "cursor_field": "id",  # No timestamp field, use snapshot
                    "ingestion_type": "snapshot",
                }

            if table_name == "tracking":
                return {
                    "primary_keys": ["transaction_id", "tracking_number"],
                    "cursor_field": "last_updated_time",
                    "ingestion_type": "cdc",
                }

            raise ValueError(f"Unsupported table: {table_name!r}")

        def read_table(
            self, table_name: str, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Read records from a table and return raw JSON-like dictionaries.

            Args:
                table_name: The name of the table to read.
                start_offset: The offset to start reading from.
                table_options: Additional options including start_date and end_date.

            Returns:
                An iterator of records in JSON format and an offset.
            """
            if table_name not in self.list_tables():
                raise ValueError(f"Unsupported table: {table_name!r}")

            if table_name == "transactions":
                return self._read_transactions(start_offset, table_options)

            if table_name == "invoices":
                return self._read_invoices(start_offset, table_options)

            if table_name == "subscriptions":
                return self._read_subscriptions(start_offset, table_options)

            if table_name == "orders":
                return self._read_orders(start_offset, table_options)

            if table_name == "products":
                return self._read_products(start_offset, table_options)

            if table_name == "plans":
                return self._read_plans(start_offset, table_options)

            if table_name == "payment_captures":
                return self._read_payment_captures(start_offset, table_options)

            if table_name == "disputes":
                return self._read_disputes(start_offset, table_options)

            if table_name == "payouts":
                return self._read_payouts(start_offset, table_options)

            if table_name == "refunds":
                return self._read_refunds(start_offset, table_options)

            if table_name == "payment_authorizations":
                return self._read_payment_authorizations(start_offset, table_options)

            if table_name == "webhooks_events":
                return self._read_webhooks_events(start_offset, table_options)

            if table_name == "payment_experiences":
                return self._read_payment_experiences(start_offset, table_options)

            if table_name == "tracking":
                return self._read_tracking(start_offset, table_options)

            raise ValueError(f"Unsupported table: {table_name!r}")

        def _read_transactions(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'transactions' table.

            Required table_options:
                - start_date: ISO 8601 date string (e.g., '2024-01-01T00:00:00Z')
                - end_date: ISO 8601 date string (e.g., '2024-01-31T23:59:59Z')

            Optional table_options:
                - page_size: Number of transactions per page (default: 100, max: 500)

            The PayPal API enforces a maximum 31-day date range per request.
            """
            start_date = table_options.get("start_date")
            end_date = table_options.get("end_date")

            if not start_date or not end_date:
                raise ValueError(
                    "table_options for 'transactions' must include 'start_date' and 'end_date' "
                    "in ISO 8601 format (e.g., '2024-01-01T00:00:00Z')"
                )

            # Validate date range (PayPal enforces 31-day maximum)
            try:
                start_dt = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
                end_dt = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
                date_range = (end_dt - start_dt).days

                if date_range > 31:
                    raise ValueError(
                        f"Date range exceeds PayPal's 31-day maximum. "
                        f"Requested range: {date_range} days. "
                        f"Please split the date range into smaller windows."
                    )
            except ValueError as e:
                if "31-day" in str(e):
                    raise
                raise ValueError(
                    f"Invalid date format. Expected ISO 8601 format "
                    f"(e.g., '2024-01-01T00:00:00Z'): {e}"
                )

            # Get page size from options (default 100, max 500)
            try:
                page_size = int(table_options.get("page_size", 100))
            except (TypeError, ValueError):
                page_size = 100
            page_size = max(1, min(page_size, 500))

            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Build query parameters
            params = {
                "start_date": start_date,
                "end_date": end_date,
                "page_size": page_size,
                "page": page,
            }

            # Make API request
            response = self._make_request("GET", "/v1/reporting/transactions", params)

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal API error for transactions: {response.status_code} {response.text}"
                )

            data = response.json()

            # Extract transaction details array
            transaction_details = data.get("transaction_details", [])
            if not isinstance(transaction_details, list):
                raise ValueError(
                    f"Unexpected response format for transaction_details: "
                    f"{type(transaction_details).__name__}"
                )

            # Process records - flatten nested objects into top-level fields
            records: list[dict[str, Any]] = []
            for txn in transaction_details:
                transaction_info = txn.get("transaction_info", {}) or {}
                payer_info = txn.get("payer_info", {}) or {}
                shipping_info = txn.get("shipping_info", {}) or {}
                cart_info = txn.get("cart_info", {}) or {}

                # Flatten all fields to top level
                record: dict[str, Any] = {
                    # Fields from transaction_info
                    "transaction_id": transaction_info.get("transaction_id"),
                    "paypal_account_id": transaction_info.get("paypal_account_id"),
                    "transaction_event_code": transaction_info.get("transaction_event_code"),
                    "transaction_initiation_date": transaction_info.get("transaction_initiation_date"),
                    "transaction_updated_date": transaction_info.get("transaction_updated_date"),
                    "transaction_amount": transaction_info.get("transaction_amount"),
                    "fee_amount": transaction_info.get("fee_amount"),
                    "transaction_status": transaction_info.get("transaction_status"),
                    "transaction_subject": transaction_info.get("transaction_subject"),
                    "ending_balance": transaction_info.get("ending_balance"),
                    "available_balance": transaction_info.get("available_balance"),
                    "invoice_id": transaction_info.get("invoice_id"),
                    "custom_field": transaction_info.get("custom_field"),
                    "protection_eligibility": transaction_info.get("protection_eligibility"),
                    # Fields from payer_info
                    "payer_account_id": payer_info.get("account_id"),
                    "payer_email_address": payer_info.get("email_address"),
                    "payer_address_status": payer_info.get("address_status"),
                    "payer_status": payer_info.get("payer_status"),
                    "payer_name": payer_info.get("payer_name"),
                    "payer_country_code": payer_info.get("country_code"),
                    # Fields from shipping_info
                    "shipping_name": shipping_info.get("name"),
                    "shipping_address": shipping_info.get("address"),
                    # Fields from cart_info
                    "item_details": cart_info.get("item_details"),
                }
                records.append(record)

            # Determine next offset based on pagination metadata
            total_pages = data.get("total_pages", 1)
            current_page = data.get("page", page)

            # If there are more pages, increment page number
            if current_page < total_pages:
                next_offset = {"page": current_page + 1}
            else:
                # No more pages - return same offset to indicate end of data
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_invoices(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'invoices' table.

            Uses PayPal Invoicing API v2: GET /v2/invoicing/invoices

            Optional table_options:
                - page: Page number (default: 1)
                - page_size: Number of invoices per page (default: 20, max: 100)
                - total_required: Whether to show total count (default: false)
            """
            # Get pagination parameters
            try:
                page_size = int(table_options.get("page_size", 20))
            except (TypeError, ValueError):
                page_size = 20
            page_size = max(1, min(page_size, 100))

            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Build query parameters
            params = {
                "page": page,
                "page_size": page_size,
                "total_required": table_options.get("total_required", "false"),
            }

            # Make API request
            try:
                response = self._make_request("GET", "/v2/invoicing/invoices", params)
            except RuntimeError as e:
                # Handle permission errors gracefully
                if "403" in str(e) or "NOT_AUTHORIZED" in str(e):
                    logger.warning("  Invoicing API requires special permissions (not available in basic Sandbox)")
                    logger.warning("   Returning empty result set. Enable Invoicing API in PayPal Developer Dashboard for full access.")
                    # Return empty result
                    next_offset = start_offset if start_offset else {"page": page}
                    return iter([]), next_offset
                # Re-raise other errors
                raise

            if response.status_code == 403:
                logger.warning("  Invoicing API requires special permissions (not available in basic Sandbox)")
                logger.warning("   Returning empty result set. Enable Invoicing API in PayPal Developer Dashboard for full access.")
                next_offset = start_offset if start_offset else {"page": page}
                return iter([]), next_offset

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal API error for invoices: {response.status_code} {response.text}"
                )

            data = response.json()

            # Extract invoices array
            invoices = data.get("items", [])
            if not isinstance(invoices, list):
                raise ValueError(
                    f"Unexpected response format for invoices: {type(invoices).__name__}"
                )

            # Process records - keep nested structure
            records: list[dict[str, Any]] = []
            for invoice in invoices:
                records.append(invoice)

            # Check if there are more pages using links
            links = data.get("links", [])
            has_next = any(link.get("rel") == "next" for link in links if isinstance(link, dict))

            # If there are more pages, increment page number
            if has_next:
                next_offset = {"page": page + 1}
            else:
                # No more pages - return same offset to indicate end of data
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_subscriptions(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'subscriptions' table.

            Uses PayPal Subscriptions API v1: GET /v1/billing/subscriptions/{id}

            IMPORTANT: This method requires explicit subscription IDs.
            You must provide subscription IDs in table_options.

            Required table_options:
                - subscription_ids: List or comma-separated string of subscription IDs
                                    Example: ["I-ABC123", "I-DEF456"] or "I-ABC123,I-DEF456"

            Note: PayPal's List Subscriptions API may not return results in Sandbox environment.
            Using explicit IDs ensures reliable data retrieval for testing.

            Subscription transactions are available via the main 'transactions' table.
            """
            # Get subscription IDs from table_options
            subscription_ids = table_options.get("subscription_ids", [])

            # Handle comma-separated string or list
            if isinstance(subscription_ids, str):
                subscription_ids = [sid.strip() for sid in subscription_ids.split(",") if sid.strip()]
            elif not isinstance(subscription_ids, list):
                raise ValueError(
                    "table_options for 'subscriptions' must include 'subscription_ids' as a list or comma-separated string. "
                    "Example: {'subscription_ids': ['I-ABC123', 'I-DEF456']} or {'subscription_ids': 'I-ABC123,I-DEF456'}. "
                    "\n\nNote: PayPal's List API may not work in Sandbox - explicit IDs are recommended."
                )

            if not subscription_ids:
                raise ValueError(
                    "table_options for 'subscriptions' must include at least one subscription ID in 'subscription_ids'. "
                    "\n\nNote: PayPal's List Subscriptions API may not return data in Sandbox. "
                    "You can find subscription IDs in your PayPal dashboard or from subscription creation responses."
                )

            # Check if we've already processed all subscriptions
            # If called again after first fetch, return empty with SAME offset
            if start_offset is not None:
                # Already processed - return empty with SAME offset to signal completion
                return iter([]), start_offset

            # First call: Fetch ALL subscription details in one batch
            records: list[dict[str, Any]] = []
            api_results = []  # Track results for each ID

            # Process ALL subscriptions
            for subscription_id in subscription_ids:
                try:
                    # Fetch subscription details
                    response = self._make_request("GET", f"/v1/billing/subscriptions/{subscription_id}")

                    if response.status_code == 200:
                        subscription_data = response.json()

                        # Note: We don't include subscription transactions here as they're 
                        # available in the main transactions table with better detail

                        records.append(subscription_data)
                        api_results.append({
                            "id": subscription_id,
                            "status": "SUCCESS",
                            "http_code": 200,
                            "subscription_status": subscription_data.get("status", "UNKNOWN")
                        })
                    else:
                        # Log error but continue (subscription might not exist or be inaccessible)
                        error_message = response.text[:200] if response.text else "No error details"
                        api_results.append({
                            "id": subscription_id,
                            "status": "FAILED",
                            "http_code": response.status_code,
                            "error": error_message
                        })
                        logger.warning(f"Could not fetch subscription {subscription_id}: {response.status_code} - {error_message}")

                except Exception as e:
                    # Log error but continue processing other subscriptions
                    api_results.append({
                        "id": subscription_id,
                        "status": "EXCEPTION",
                        "error": str(e)
                    })
                    logger.warning(f"Error fetching subscription {subscription_id}: {e}")

            # Log summary of API call results (for monitoring and debugging)
            successful = sum(1 for r in api_results if r["status"] == "SUCCESS")
            failed = len(api_results) - successful

            logger.info("="*70)
            logger.info("SUBSCRIPTIONS API CALL SUMMARY")
            logger.info("="*70)
            logger.info(f"Total subscription IDs requested: {len(subscription_ids)}")
            logger.info(f"Successfully fetched: {successful}")
            logger.info(f"Failed to fetch: {failed}")
            logger.info(f"Records in dataframe before return: {len(records)}")

            if failed > 0:
                logger.warning(f"  {failed}/{len(subscription_ids)} subscription(s) could not be fetched")
                logger.warning("Failed subscriptions:")
                for result in api_results:
                    if result["status"] != "SUCCESS":
                        if result.get("http_code"):
                            logger.warning(f"  - {result['id']}: HTTP {result['http_code']} - {result.get('error', 'Unknown error')}")
                        else:
                            logger.warning(f"  - {result['id']}: {result.get('error', 'Unknown error')}")

            if len(records) == 0:
                logger.error(" CRITICAL: Returning 0 records!")
                logger.error(f"   All {len(subscription_ids)} subscription ID(s) failed to fetch.")
                logger.error("   This will result in an empty table.")
                logger.error("   Common causes:")
                logger.error("     - Subscription IDs don't exist or have been deleted")
                logger.error("     - Subscription IDs from different PayPal account")
                logger.error("     - PayPal Sandbox was reset")
                logger.error("     - API authentication issue")

            logger.info("="*70)

            # CRITICAL: Return empty dict {} as next_offset to signal completion
            # Databricks rule: First call gets None, returns {}
            #                  Next call gets {}, returns {} (same = done)
            next_offset = {}

            return iter(records), next_offset

        def _read_orders(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'orders' table.

            Note: PayPal Orders API v2 does not provide a direct "list all orders" endpoint.
            Orders are typically created and retrieved by ID, or accessed through 
            Transaction Search API.

            This implementation attempts to use available endpoints, but may have limitations.
            Consider using the 'transactions' table for order history instead.
            """
            # PayPal Orders API v2 is primarily for creating/managing individual orders
            # There is no bulk "list orders" endpoint in the standard API

            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Since there's no list endpoint, return empty result with warning
            logger.warning("  PayPal Orders API v2 does not support bulk order listing")
            logger.warning("   Orders can only be retrieved individually by ID")
            logger.warning("    Use the 'transactions' table for comprehensive payment history including orders")
            logger.warning("   Returning empty result set.")

            # Return empty result to allow connector to function
            next_offset = start_offset if start_offset else {"page": page}
            return iter([]), next_offset

        def _read_products(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'products' table.

            Uses PayPal Catalog Products API v1: GET /v1/catalogs/products

            Optional table_options:
                - page: Page number (default: 1)
                - page_size: Number of products per page (default: 20, max: 20)
            """
            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Get page size from options (default 20, max 20)
            try:
                page_size = int(table_options.get("page_size", 20))
            except (TypeError, ValueError):
                page_size = 20
            page_size = max(1, min(page_size, 20))

            # Build query parameters
            params = {
                "page": page,
                "page_size": page_size,
            }

            # Make API request
            response = self._make_request("GET", "/v1/catalogs/products", params)

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal API error for products: {response.status_code} {response.text}"
                )

            data = response.json()

            # Extract products array
            products = data.get("products", [])
            if not isinstance(products, list):
                raise ValueError(
                    f"Unexpected response format for products: {type(products).__name__}"
                )

            # Process records
            records: list[dict[str, Any]] = []
            for product in products:
                records.append(product)

            # Check for pagination
            total_items = data.get("total_items", 0)
            total_pages = data.get("total_pages", 1)

            # If there are more pages, increment page number
            if page < total_pages:
                next_offset = {"page": page + 1}
            else:
                # No more pages - return same offset to indicate end of data
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_plans(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'plans' table.

            Uses PayPal Subscriptions API v1: GET /v1/billing/plans

            Optional table_options:
                - product_id: Filter by product ID
                - plan_ids: Comma-separated plan IDs to filter
                - page: Page number (default: 1)
                - page_size: Number of plans per page (default: 20, max: 20)
            """
            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Get page size from options (default 20, max 20)
            try:
                page_size = int(table_options.get("page_size", 20))
            except (TypeError, ValueError):
                page_size = 20
            page_size = max(1, min(page_size, 20))

            # Build query parameters
            params = {
                "page": page,
                "page_size": page_size,
            }

            # Add optional filters
            if table_options.get("product_id"):
                params["product_id"] = table_options["product_id"]
            if table_options.get("plan_ids"):
                params["plan_ids"] = table_options["plan_ids"]

            # Make API request
            response = self._make_request("GET", "/v1/billing/plans", params)

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal API error for plans: {response.status_code} {response.text}"
                )

            data = response.json()

            # Extract plans array
            plans = data.get("plans", [])
            if not isinstance(plans, list):
                raise ValueError(
                    f"Unexpected response format for plans: {type(plans).__name__}"
                )

            # Process records
            records: list[dict[str, Any]] = []
            for plan in plans:
                records.append(plan)

            # Check for pagination
            total_items = data.get("total_items", 0)
            total_pages = data.get("total_pages", 1)

            # If there are more pages, increment page number
            if page < total_pages:
                next_offset = {"page": page + 1}
            else:
                # No more pages - return same offset to indicate end of data
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_payment_captures(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'payment_captures' table.

            Uses PayPal Transaction Search API v1 to find captures: GET /v1/reporting/transactions

            Required table_options:
                - start_date: Start of date range in ISO 8601 format (UTC)
                - end_date: End of date range in ISO 8601 format (UTC)

            Optional table_options:
                - page_size: Number of captures per page (default: 100, max: 500)

            Note: This uses the Transaction Search API and filters for capture transactions only.
            """
            start_date = table_options.get("start_date")
            end_date = table_options.get("end_date")

            if not start_date or not end_date:
                raise ValueError(
                    "table_options for 'payment_captures' must include 'start_date' and 'end_date' "
                    "in ISO 8601 format (e.g., '2024-01-01T00:00:00Z')"
                )

            # Validate date range (PayPal enforces 31-day maximum)
            try:
                start_dt = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
                end_dt = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
                date_range = (end_dt - start_dt).days

                if date_range > 31:
                    raise ValueError(
                        f"Date range exceeds PayPal's 31-day maximum. "
                        f"Requested range: {date_range} days. "
                        f"Please split the date range into smaller windows."
                    )
            except ValueError as e:
                if "31-day" in str(e):
                    raise
                raise ValueError(
                    f"Invalid date format. Expected ISO 8601 format "
                    f"(e.g., '2024-01-01T00:00:00Z'): {e}"
                )

            # Get page size from options (default 100, max 500)
            try:
                page_size = int(table_options.get("page_size", 100))
            except (TypeError, ValueError):
                page_size = 100
            page_size = max(1, min(page_size, 500))

            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            # Build query parameters
            params = {
                "start_date": start_date,
                "end_date": end_date,
                "page_size": page_size,
                "page": page,
            }

            # Make API request
            response = self._make_request("GET", "/v1/reporting/transactions", params)

            if response.status_code != 200:
                raise RuntimeError(
                    f"PayPal API error for payment_captures: {response.status_code} {response.text}"
                )

            data = response.json()

            # Extract transaction details array
            transaction_details = data.get("transaction_details", [])
            if not isinstance(transaction_details, list):
                raise ValueError(
                    f"Unexpected response format for transaction_details: "
                    f"{type(transaction_details).__name__}"
                )

            # Process records - extract capture information from transactions
            records: list[dict[str, Any]] = []
            for txn in transaction_details:
                transaction_info = txn.get("transaction_info", {}) or {}

                # Build a capture record from transaction data
                record: dict[str, Any] = {
                    "id": transaction_info.get("transaction_id"),
                    "status": "COMPLETED" if transaction_info.get("transaction_status") == "S" else "PENDING",
                    "status_details": None,
                    "amount": transaction_info.get("transaction_amount"),
                    "invoice_id": transaction_info.get("invoice_id"),
                    "custom_id": transaction_info.get("custom_field"),
                    "seller_protection": {
                        "status": transaction_info.get("protection_eligibility"),
                        "dispute_categories": None,
                    },
                    "final_capture": True,
                    "seller_receivable_breakdown": {
                        "gross_amount": transaction_info.get("transaction_amount"),
                        "paypal_fee": transaction_info.get("fee_amount"),
                        "net_amount": transaction_info.get("ending_balance"),
                        "receivable_amount": transaction_info.get("transaction_amount"),
                        "exchange_rate": None,
                        "platform_fees": None,
                    },
                    "disbursement_mode": "INSTANT",
                    "create_time": transaction_info.get("transaction_initiation_date"),
                    "update_time": transaction_info.get("transaction_updated_date"),
                    "links": None,
                }
                records.append(record)

            # Determine next offset based on pagination metadata
            total_pages = data.get("total_pages", 1)
            current_page = data.get("page", page)

            # If there are more pages, increment page number
            if current_page < total_pages:
                next_offset = {"page": current_page + 1}
            else:
                # No more pages - return same offset to indicate end of data
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset


        def _read_disputes(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'disputes' table.

            Uses PayPal Disputes API v1: GET /v1/customer/disputes

            Optional table_options:
                - start_time: Filter disputes created after this time (ISO 8601)
                - disputed_transaction_id: Filter by transaction ID
                - page_size: Number of disputes per page (default: 10, max: 50)
            """
            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            page_size = int(table_options.get("page_size", 10))
            params = {
                "page_size": page_size,
                "page": page,
            }

            # Add optional filters
            if "start_time" in table_options:
                params["start_time"] = table_options["start_time"]
            if "disputed_transaction_id" in table_options:
                params["disputed_transaction_id"] = table_options["disputed_transaction_id"]

            logger.info(f"Fetching disputes (page {page}, size {page_size})")
            response = self._make_request("GET", "/v1/customer/disputes", params=params)
            data = response.json()

            records = []
            for item in data.get("items", []):
                records.append(item)

            logger.info(f"Fetched {len(records)} disputes")

            # Check if there are more pages
            total_pages = data.get("total_pages", 1)
            if page < total_pages:
                next_offset = {"page": page + 1}
            else:
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_payouts(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'payouts' table.

            Uses PayPal Payouts API v1: GET /v1/payments/payouts

            Optional table_options:
                - start_date: Filter payouts created after this date (YYYY-MM-DD)
                - end_date: Filter payouts created before this date (YYYY-MM-DD)
                - page_size: Number of payouts per page (default: 10, max: 100)
            """
            # Get starting page from offset (default 1)
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            page_size = int(table_options.get("page_size", 10))
            params = {
                "page_size": page_size,
                "page": page,
            }

            # Add optional date filters
            if "start_date" in table_options:
                params["start_date"] = table_options["start_date"]
            if "end_date" in table_options:
                params["end_date"] = table_options["end_date"]

            logger.info(f"Fetching payouts (page {page}, size {page_size})")
            # Note: PayPal Payouts API uses /v1/payment/payouts-item for historical payouts
            # The /v1/payments/payouts endpoint is for creating payouts, not listing them
            # We'll try the payouts-item endpoint which lists payout items
            try:
                response = self._make_request("GET", "/v1/payments/payouts-item", params=params)
            except RuntimeError as e:
                # Handle API errors gracefully
                if "404" in str(e):
                    logger.warning("  Payouts API endpoint not available or no payouts exist")
                    logger.warning("   Payouts must be created first before they can be retrieved")
                    logger.warning("   Returning empty result set.")
                    # Return empty result
                    next_offset = start_offset if start_offset else {"page": page}
                    return iter([]), next_offset
                # Re-raise other errors
                raise
            data = response.json()

            records = []
            for item in data.get("items", []):
                # Flatten batch_header into the record
                record = {
                    "batch_id": item.get("batch_header", {}).get("payout_batch_id"),
                    "payout_batch_id": item.get("batch_header", {}).get("payout_batch_id"),
                    "batch_status": item.get("batch_header", {}).get("batch_status"),
                    "time_created": item.get("batch_header", {}).get("time_created"),
                    "time_completed": item.get("batch_header", {}).get("time_completed"),
                    "sender_batch_header": item.get("batch_header", {}).get("sender_batch_header"),
                    "amount": item.get("batch_header", {}).get("amount"),
                    "fees": item.get("batch_header", {}).get("fees"),
                    "links": item.get("links"),
                }
                records.append(record)

            logger.info(f"Fetched {len(records)} payouts")

            # Check if there are more pages
            total_pages = data.get("total_pages", 1)
            if page < total_pages:
                next_offset = {"page": page + 1}
            else:
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_refunds(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'refunds' table.

            Note: PayPal Payments API v2 does not have a bulk list refunds endpoint.
            This method extracts refund data from the transactions table.

            Required table_options:
                - start_date: Start date for transaction search (YYYY-MM-DDTHH:MM:SSZ)
                - end_date: End date for transaction search (YYYY-MM-DDTHH:MM:SSZ)
            """
            # Use transactions API and filter for refunds
            # Get starting page from offset
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            start_date = table_options.get("start_date")
            end_date = table_options.get("end_date")

            if not start_date or not end_date:
                raise ValueError("start_date and end_date are required for refunds table")

            page_size = 100
            params = {
                "start_date": start_date,
                "end_date": end_date,
                "page": page,
                "page_size": page_size,
                "transaction_type": "T1106",  # Refund transaction type
            }

            logger.info(f"Fetching refunds from transactions (page {page})")
            response = self._make_request("GET", "/v1/reporting/transactions", params=params)
            data = response.json()

            records = []
            for detail in data.get("transaction_details", []):
                transaction_info = detail.get("transaction_info", {})
                # Map transaction data to refund schema
                record = {
                    "id": transaction_info.get("transaction_id"),
                    "status": "COMPLETED" if transaction_info.get("transaction_status") == "S" else "PENDING",
                    "status_details": {"reason": transaction_info.get("transaction_note")},
                    "amount": transaction_info.get("transaction_amount"),
                    "invoice_id": transaction_info.get("invoice_id"),
                    "custom_id": transaction_info.get("custom_field"),
                    "acquirer_reference_number": None,
                    "note_to_payer": transaction_info.get("transaction_subject"),
                    "seller_payable_breakdown": {
                        "gross_amount": transaction_info.get("transaction_amount"),
                        "paypal_fee": transaction_info.get("fee_amount"),
                        "net_amount": transaction_info.get("ending_balance"),
                        "total_refunded_amount": transaction_info.get("transaction_amount"),
                    },
                    "create_time": transaction_info.get("transaction_initiation_date"),
                    "update_time": transaction_info.get("transaction_updated_date"),
                    "links": None,
                }
                records.append(record)

            logger.info(f"Fetched {len(records)} refunds")

            # Determine next offset
            total_pages = data.get("total_pages", 1)
            current_page = data.get("page", page)

            if current_page < total_pages:
                next_offset = {"page": current_page + 1}
            else:
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_payment_authorizations(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'payment_authorizations' table.

            Note: PayPal Payments API v2 does not have a bulk list authorizations endpoint.
            This method extracts authorization data from the transactions table.

            Required table_options:
                - start_date: Start date for transaction search (YYYY-MM-DDTHH:MM:SSZ)
                - end_date: End date for transaction search (YYYY-MM-DDTHH:MM:SSZ)
            """
            # Use transactions API and filter for authorizations
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            start_date = table_options.get("start_date")
            end_date = table_options.get("end_date")

            if not start_date or not end_date:
                raise ValueError("start_date and end_date are required for payment_authorizations table")

            page_size = 100
            params = {
                "start_date": start_date,
                "end_date": end_date,
                "page": page,
                "page_size": page_size,
                "transaction_type": "T0001",  # Authorization transaction type
            }

            logger.info(f"Fetching payment authorizations from transactions (page {page})")
            response = self._make_request("GET", "/v1/reporting/transactions", params=params)
            data = response.json()

            records = []
            for detail in data.get("transaction_details", []):
                transaction_info = detail.get("transaction_info", {})
                # Map transaction data to authorization schema
                record = {
                    "id": transaction_info.get("transaction_id"),
                    "status": "CREATED" if transaction_info.get("transaction_status") == "S" else "PENDING",
                    "status_details": {"reason": transaction_info.get("transaction_note")},
                    "amount": transaction_info.get("transaction_amount"),
                    "invoice_id": transaction_info.get("invoice_id"),
                    "custom_id": transaction_info.get("custom_field"),
                    "seller_protection": {
                        "status": transaction_info.get("protection_eligibility"),
                        "dispute_categories": None,
                    },
                    "expiration_time": None,  # Not available in transaction search
                    "create_time": transaction_info.get("transaction_initiation_date"),
                    "update_time": transaction_info.get("transaction_updated_date"),
                    "links": None,
                }
                records.append(record)

            logger.info(f"Fetched {len(records)} payment authorizations")

            # Determine next offset
            total_pages = data.get("total_pages", 1)
            current_page = data.get("page", page)

            if current_page < total_pages:
                next_offset = {"page": current_page + 1}
            else:
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_webhooks_events(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'webhooks_events' table.

            Uses PayPal Webhooks API v1: GET /v1/notifications/webhooks-events

            Optional table_options:
                - start_time: Filter events created after this time (ISO 8601)
                - end_time: Filter events created before this time (ISO 8601)
                - event_type: Filter by specific event type
                - page_size: Number of events per page (default: 10, max: 300)
            """
            # Get starting page from offset
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            page_size = int(table_options.get("page_size", 10))
            params = {
                "page_size": page_size,
                "page": page,
            }

            # Add optional filters
            if "start_time" in table_options:
                params["start_time"] = table_options["start_time"]
            if "end_time" in table_options:
                params["end_time"] = table_options["end_time"]
            if "event_type" in table_options:
                params["event_type"] = table_options["event_type"]

            logger.info(f"Fetching webhook events (page {page}, size {page_size})")
            response = self._make_request("GET", "/v1/notifications/webhooks-events", params=params)
            data = response.json()

            import json
            records = []
            for event in data.get("events", []):
                # Convert resource object to JSON string
                resource = event.get("resource")
                if resource and isinstance(resource, dict):
                    resource = json.dumps(resource)

                record = {
                    "id": event.get("id"),
                    "create_time": event.get("create_time"),
                    "resource_type": event.get("resource_type"),
                    "event_version": event.get("event_version"),
                    "event_type": event.get("event_type"),
                    "summary": event.get("summary"),
                    "resource": resource,
                    "links": event.get("links"),
                }
                records.append(record)

            logger.info(f"Fetched {len(records)} webhook events")

            # Check if there are more pages
            total_pages = data.get("total_pages", 1)
            if page < total_pages:
                next_offset = {"page": page + 1}
            else:
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset

        def _read_payment_experiences(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'payment_experiences' table.

            Uses PayPal Payment Experience API v1: GET /v1/payment-experience/web-profiles

            Note: This API returns all web profiles in a single call (no pagination).
            """
            logger.info("Fetching payment experiences (web profiles)")
            response = self._make_request("GET", "/v1/payment-experience/web-profiles")

            # API returns array directly
            profiles = response.json() if isinstance(response.json(), list) else []

            records = []
            for profile in profiles:
                records.append(profile)

            logger.info(f"Fetched {len(records)} payment experiences")

            # No pagination - return same offset to signal completion
            next_offset = start_offset if start_offset else {}

            return iter(records), next_offset

        def _read_tracking(
            self, start_offset: dict, table_options: dict[str, str]
        ) -> (Iterator[dict], dict):
            """
            Internal implementation for reading the 'tracking' table.

            Uses PayPal Tracking API v1: GET /v1/shipping/trackers

            Optional table_options:
                - transaction_id: Filter by transaction ID
                - tracking_number: Filter by tracking number
                - start_date: Filter by shipment date (YYYY-MM-DD)
                - end_date: Filter by shipment date (YYYY-MM-DD)
                - page_size: Number of trackers per page (default: 10, max: 20)
            """
            # Get starting page from offset
            if start_offset and isinstance(start_offset, dict):
                page = start_offset.get("page", 1)
            else:
                page = 1

            page_size = int(table_options.get("page_size", 10))
            params = {
                "page_size": page_size,
                "page": page,
            }

            # Add optional filters
            if "transaction_id" in table_options:
                params["transaction_id"] = table_options["transaction_id"]
            if "tracking_number" in table_options:
                params["tracking_number"] = table_options["tracking_number"]
            if "start_date" in table_options:
                params["start_date"] = table_options["start_date"]
            if "end_date" in table_options:
                params["end_date"] = table_options["end_date"]

            logger.info(f"Fetching tracking info (page {page}, size {page_size})")

            try:
                response = self._make_request("GET", "/v1/shipping/trackers", params=params)
                data = response.json()
            except RuntimeError as e:
                # Handle API errors gracefully
                if "400" in str(e) or "INVALID_TRANSACTION_ID" in str(e):
                    logger.warning("  Tracking API requires at least one filter (transaction_id, tracking_number, or date range)")
                    logger.warning("   Provide transaction_id, tracking_number, start_date, or end_date in table_options")
                    logger.warning("   Returning empty result set.")
                    # Return empty result
                    next_offset = start_offset if start_offset else {"page": page}
                    return iter([]), next_offset
                # Re-raise other errors
                raise

            records = []
            for tracker in data.get("trackers", []):
                records.append(tracker)

            logger.info(f"Fetched {len(records)} tracking records")

            # Check if there are more pages
            total_items = data.get("total_items", len(records))
            if (page * page_size) < total_items:
                next_offset = {"page": page + 1}
            else:
                next_offset = start_offset if start_offset else {"page": page}

            return iter(records), next_offset


    ########################################################
    # pipeline/lakeflow_python_source.py
    ########################################################

    METADATA_TABLE = "_lakeflow_metadata"
    TABLE_NAME = "tableName"
    TABLE_NAME_LIST = "tableNameList"
    TABLE_CONFIGS = "tableConfigs"
    IS_DELETE_FLOW = "isDeleteFlow"


    class LakeflowStreamReader(SimpleDataSourceStreamReader):
        """
        Implements a data source stream reader for Lakeflow Connect.
        Currently, only the simpleStreamReader is implemented, which uses a
        more generic protocol suitable for most data sources that support
        incremental loading.
        """

        def __init__(
            self,
            options: dict[str, str],
            schema: StructType,
            lakeflow_connect: LakeflowConnect,
        ):
            self.options = options
            self.lakeflow_connect = lakeflow_connect
            self.schema = schema

        def initialOffset(self):
            return {}

        def read(self, start: dict) -> (Iterator[tuple], dict):
            is_delete_flow = self.options.get(IS_DELETE_FLOW) == "true"
            # Strip delete flow options before passing to connector
            table_options = {
                k: v for k, v in self.options.items() if k != IS_DELETE_FLOW
            }

            if is_delete_flow:
                records, offset = self.lakeflow_connect.read_table_deletes(
                    self.options[TABLE_NAME], start, table_options
                )
            else:
                records, offset = self.lakeflow_connect.read_table(
                    self.options[TABLE_NAME], start, table_options
                )
            rows = map(lambda x: parse_value(x, self.schema), records)
            return rows, offset

        def readBetweenOffsets(self, start: dict, end: dict) -> Iterator[tuple]:
            # TODO: This does not ensure the records returned are identical across repeated calls.
            # For append-only tables, the data source must guarantee that reading from the same
            # start offset will always yield the same set of records.
            # For tables ingested as incremental CDC, it is only necessary that no new changes
            # are missed in the returned records.
            return self.read(start)[0]


    class LakeflowBatchReader(DataSourceReader):
        def __init__(
            self,
            options: dict[str, str],
            schema: StructType,
            lakeflow_connect: LakeflowConnect,
        ):
            self.options = options
            self.schema = schema
            self.lakeflow_connect = lakeflow_connect
            self.table_name = options[TABLE_NAME]

        def read(self, partition):
            all_records = []
            if self.table_name == METADATA_TABLE:
                all_records = self._read_table_metadata()
            else:
                all_records, _ = self.lakeflow_connect.read_table(
                    self.table_name, None, self.options
                )

            rows = map(lambda x: parse_value(x, self.schema), all_records)
            return iter(rows)

        def _read_table_metadata(self):
            table_name_list = self.options.get(TABLE_NAME_LIST, "")
            table_names = [o.strip() for o in table_name_list.split(",") if o.strip()]
            all_records = []
            table_configs = json.loads(self.options.get(TABLE_CONFIGS, "{}"))
            for table in table_names:
                metadata = self.lakeflow_connect.read_table_metadata(
                    table, table_configs.get(table, {})
                )
                all_records.append({TABLE_NAME: table, **metadata})
            return all_records


    class LakeflowSource(DataSource):
        def __init__(self, options):
            self.options = options
            self.lakeflow_connect = LakeflowConnect(options)

        @classmethod
        def name(cls):
            return "lakeflow_connect"

        def schema(self):
            table = self.options[TABLE_NAME]
            if table == METADATA_TABLE:
                return StructType(
                    [
                        StructField(TABLE_NAME, StringType(), False),
                        StructField("primary_keys", ArrayType(StringType()), True),
                        StructField("cursor_field", StringType(), True),
                        StructField("ingestion_type", StringType(), True),
                    ]
                )
            else:
                # Assuming the LakeflowConnect interface uses get_table_schema, not get_table_details
                return self.lakeflow_connect.get_table_schema(table, self.options)

        def reader(self, schema: StructType):
            return LakeflowBatchReader(self.options, schema, self.lakeflow_connect)

        def simpleStreamReader(self, schema: StructType):
            return LakeflowStreamReader(self.options, schema, self.lakeflow_connect)


    spark.dataSource.register(LakeflowSource)  # pylint: disable=undefined-variable
